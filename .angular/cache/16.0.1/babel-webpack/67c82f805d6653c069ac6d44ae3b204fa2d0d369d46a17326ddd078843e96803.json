{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/luisc/Desktop/clase/Ionic/Moviesostenible/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { r as registerInstance, c as createEvent, d as getIonMode, h, H as Host, e as getElement } from './core-ca0488fc.js';\nimport './config-3c7f3790.js';\nimport { f as findItemLabel } from './helpers-46f4a262.js';\nimport { c as createColorClasses, h as hostContext } from './theme-18cbe2cc.js';\nimport { f as findCheckedOption, w as watchForOptions } from './watch-options-2af96011.js';\nconst Radio = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.inputId = `ion-rb-${radioButtonIds++}`;\n    /**\n     * The name of the control, which is submitted with the form data.\n     */\n    this.name = this.inputId;\n    /**\n     * If `true`, the user cannot interact with the radio.\n     */\n    this.disabled = false;\n    /**\n     * If `true`, the radio is selected.\n     */\n    this.checked = false;\n    this.onFocus = () => {\n      this.ionFocus.emit();\n    };\n    this.onBlur = () => {\n      this.ionBlur.emit();\n    };\n    this.onClick = () => {\n      if (this.checked) {\n        this.ionDeselect.emit();\n      } else {\n        this.checked = true;\n      }\n    };\n    this.ionStyle = createEvent(this, \"ionStyle\", 7);\n    this.ionSelect = createEvent(this, \"ionSelect\", 7);\n    this.ionDeselect = createEvent(this, \"ionDeselect\", 7);\n    this.ionFocus = createEvent(this, \"ionFocus\", 7);\n    this.ionBlur = createEvent(this, \"ionBlur\", 7);\n  }\n  colorChanged() {\n    this.emitStyle();\n  }\n  checkedChanged(isChecked) {\n    if (isChecked) {\n      this.ionSelect.emit({\n        checked: true,\n        value: this.value\n      });\n    }\n    this.emitStyle();\n  }\n  disabledChanged() {\n    this.emitStyle();\n  }\n  componentWillLoad() {\n    if (this.value === undefined) {\n      this.value = this.inputId;\n    }\n    this.emitStyle();\n  }\n  emitStyle() {\n    this.ionStyle.emit({\n      'radio-checked': this.checked,\n      'interactive-disabled': this.disabled\n    });\n  }\n  render() {\n    const {\n      inputId,\n      disabled,\n      checked,\n      color,\n      el\n    } = this;\n    const mode = getIonMode(this);\n    const labelId = inputId + '-lbl';\n    const label = findItemLabel(el);\n    if (label) {\n      label.id = labelId;\n    }\n    return h(Host, {\n      onClick: this.onClick,\n      role: \"radio\",\n      \"aria-disabled\": disabled ? 'true' : null,\n      \"aria-checked\": `${checked}`,\n      \"aria-labelledby\": labelId,\n      class: Object.assign(Object.assign({}, createColorClasses(color)), {\n        [mode]: true,\n        'in-item': hostContext('ion-item', el),\n        'interactive': true,\n        'radio-checked': checked,\n        'radio-disabled': disabled\n      })\n    }, h(\"div\", {\n      class: \"radio-icon\"\n    }, h(\"div\", {\n      class: \"radio-inner\"\n    })), h(\"button\", {\n      type: \"button\",\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      disabled: disabled\n    }));\n  }\n  get el() {\n    return getElement(this);\n  }\n  static get watchers() {\n    return {\n      \"color\": [\"colorChanged\"],\n      \"checked\": [\"checkedChanged\"],\n      \"disabled\": [\"disabledChanged\"]\n    };\n  }\n  static get style() {\n    return \":host{display:inline-block;position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.radio-disabled){pointer-events:none}.radio-icon{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;contain:layout size style}.radio-icon,button{width:100%;height:100%}button{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none}:host-context([dir=rtl]) button,[dir=rtl] button{left:unset;right:unset;right:0}button::-moz-focus-inner{border:0}.radio-icon,.radio-inner{-webkit-box-sizing:border-box;box-sizing:border-box}:host{--color:var(--ion-color-step-400,#999);--color-checked:var(--ion-color-primary,#3880ff);--border-width:2px;--border-style:solid;width:20px;height:20px}:host(.ion-color) .radio-inner{background:var(--ion-color-base)}:host(.ion-color.radio-checked) .radio-icon{border-color:var(--ion-color-base)}.radio-icon{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:50%;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--color)}.radio-inner{border-radius:50%;width:calc(50% + var(--border-width));height:calc(50% + var(--border-width));-webkit-transform:scale3d(0,0,0);transform:scale3d(0,0,0);-webkit-transition:-webkit-transform .28s cubic-bezier(.4,0,.2,1);transition:-webkit-transform .28s cubic-bezier(.4,0,.2,1);transition:transform .28s cubic-bezier(.4,0,.2,1);transition:transform .28s cubic-bezier(.4,0,.2,1),-webkit-transform .28s cubic-bezier(.4,0,.2,1);background:var(--color-checked)}:host(.radio-checked) .radio-icon{border-color:var(--color-checked)}:host(.radio-checked) .radio-inner{-webkit-transform:scaleX(1);transform:scaleX(1)}:host(.radio-disabled){opacity:.3}:host(.ion-focused) .radio-icon:after{border-radius:50%;left:-12px;top:-12px;display:block;position:absolute;width:36px;height:36px;background:var(--ion-color-primary-tint,#4c8dff);content:\\\"\\\";opacity:.2}:host-context([dir=rtl]).ion-focused .radio-icon:after,:host-context([dir=rtl]):host(.ion-focused) .radio-icon:after{left:unset;right:unset;right:-12px}:host(.in-item){margin-left:0;margin-right:0;margin-top:9px;margin-bottom:9px;display:block;position:static}:host(.in-item[slot=start]){margin-left:4px;margin-right:36px;margin-top:11px;margin-bottom:10px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host(.in-item[slot=start]){margin-left:unset;margin-right:unset;-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:36px;margin-inline-end:36px}}\";\n  }\n};\nlet radioButtonIds = 0;\nconst RadioGroup = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.inputId = `ion-rg-${radioGroupIds++}`;\n    this.labelId = `${this.inputId}-lbl`;\n    /**\n     * If `true`, the radios can be deselected.\n     */\n    this.allowEmptySelection = false;\n    /**\n     * The name of the control, which is submitted with the form data.\n     */\n    this.name = this.inputId;\n    this.onSelect = ev => {\n      const selectedRadio = ev.target;\n      if (selectedRadio) {\n        this.value = selectedRadio.value;\n      }\n    };\n    this.onDeselect = ev => {\n      const selectedRadio = ev.target;\n      if (selectedRadio) {\n        selectedRadio.checked = false;\n        this.value = undefined;\n      }\n    };\n    this.ionChange = createEvent(this, \"ionChange\", 7);\n  }\n  valueChanged(value) {\n    this.updateRadios();\n    this.ionChange.emit({\n      value\n    });\n  }\n  connectedCallback() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Get the list header if it exists and set the id\n      // this is used to set aria-labelledby\n      const el = _this.el;\n      const header = el.querySelector('ion-list-header') || el.querySelector('ion-item-divider');\n      if (header) {\n        const label = header.querySelector('ion-label');\n        if (label) {\n          _this.labelId = label.id = _this.name + '-lbl';\n        }\n      }\n      if (_this.value === undefined) {\n        const radio = findCheckedOption(el, 'ion-radio');\n        if (radio !== undefined) {\n          yield radio.componentOnReady();\n          if (_this.value === undefined) {\n            _this.value = radio.value;\n          }\n        }\n      }\n      _this.mutationO = watchForOptions(el, 'ion-radio', newOption => {\n        if (newOption !== undefined) {\n          newOption.componentOnReady().then(() => {\n            _this.value = newOption.value;\n          });\n        } else {\n          _this.updateRadios();\n        }\n      });\n      _this.updateRadios();\n    })();\n  }\n  disconnectedCallback() {\n    if (this.mutationO) {\n      this.mutationO.disconnect();\n      this.mutationO = undefined;\n    }\n  }\n  updateRadios() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      /**\n       * Make sure we get all radios first\n       * so values are up to date prior\n       * to caching the radio group value\n       */\n      const radios = yield _this2.getRadios();\n      const {\n        value\n      } = _this2;\n      let hasChecked = false;\n      // Walk the DOM in reverse order, since the last selected one wins!\n      for (const radio of radios) {\n        if (!hasChecked && radio.value === value) {\n          // correct value for this radio\n          // but this radio isn't checked yet\n          // and we haven't found a checked yet\n          hasChecked = true;\n          radio.checked = true;\n        } else {\n          // this radio doesn't have the correct value\n          // or the radio group has been already checked\n          radio.checked = false;\n        }\n      }\n      // Reset value if\n      if (!hasChecked) {\n        _this2.value = undefined;\n      }\n    })();\n  }\n  getRadios() {\n    return Promise.all(Array.from(this.el.querySelectorAll('ion-radio')).map(r => r.componentOnReady()));\n  }\n  render() {\n    return h(Host, {\n      role: \"radiogroup\",\n      \"aria-labelledby\": this.labelId,\n      onIonSelect: this.onSelect,\n      onIonDeselect: this.allowEmptySelection ? this.onDeselect : undefined,\n      class: getIonMode(this)\n    });\n  }\n  get el() {\n    return getElement(this);\n  }\n  static get watchers() {\n    return {\n      \"value\": [\"valueChanged\"]\n    };\n  }\n};\nlet radioGroupIds = 0;\nexport { Radio as ion_radio, RadioGroup as ion_radio_group };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
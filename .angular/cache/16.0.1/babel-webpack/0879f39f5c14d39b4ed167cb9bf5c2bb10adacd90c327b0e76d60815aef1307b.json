{"ast":null,"code":"import { __extends, __awaiter, __generator, __assign } from 'tslib';\nimport { HostListener, Directive, ElementRef, Injectable, Inject, NgZone, defineInjectable, inject, Optional, Component, ChangeDetectionStrategy, ChangeDetectorRef, InjectionToken, ApplicationRef, Injector, ViewContainerRef, ComponentFactoryResolver, Attribute, SkipSelf, Output, EventEmitter, ViewChild, ContentChild, TemplateRef, IterableDiffers, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOCUMENT, Location, LocationStrategy, CommonModule } from '@angular/common';\nimport { UrlSerializer, Router, NavigationStart, ActivatedRoute, ChildrenOutletContexts, PRIMARY_OUTLET, RouterLink } from '@angular/router';\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, actionSheetController, alertController, loadingController, menuController, pickerController, modalController, popoverController, toastController } from '@ionic/core';\nimport { Subject, fromEvent, BehaviorSubject } from 'rxjs';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport { applyPolyfills, defineCustomElements } from '@ionic/core/loader';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar raf =\n/**\n* @param {?} h\n* @return {?}\n*/\nfunction (h) {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ValueAccessor = /** @class */function () {\n  function ValueAccessor(el) {\n    this.el = el;\n    this.onChange =\n    /**\n    * @return {?}\n    */\n    function () {};\n    this.onTouched =\n    /**\n    * @return {?}\n    */\n    function () {};\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  ValueAccessor.prototype.writeValue =\n  /**\n  * @param {?} value\n  * @return {?}\n  */\n  function (value) {\n    this.el.nativeElement.value = this.lastValue = value == null ? '' : value;\n    setIonicClasses(this.el);\n  };\n  /**\n   * @param {?} el\n   * @param {?} value\n   * @return {?}\n   */\n  ValueAccessor.prototype.handleChangeEvent =\n  /**\n  * @param {?} el\n  * @param {?} value\n  * @return {?}\n  */\n  function (el, value) {\n    if (el === this.el.nativeElement) {\n      if (value !== this.lastValue) {\n        this.lastValue = value;\n        this.onChange(value);\n      }\n      setIonicClasses(this.el);\n    }\n  };\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  ValueAccessor.prototype._handleBlurEvent =\n  /**\n  * @param {?} el\n  * @return {?}\n  */\n  function (el) {\n    if (el === this.el.nativeElement) {\n      this.onTouched();\n      setIonicClasses(this.el);\n    }\n  };\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  ValueAccessor.prototype.registerOnChange =\n  /**\n  * @param {?} fn\n  * @return {?}\n  */\n  function (fn) {\n    this.onChange = fn;\n  };\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  ValueAccessor.prototype.registerOnTouched =\n  /**\n  * @param {?} fn\n  * @return {?}\n  */\n  function (fn) {\n    this.onTouched = fn;\n  };\n  /**\n   * @param {?} isDisabled\n   * @return {?}\n   */\n  ValueAccessor.prototype.setDisabledState =\n  /**\n  * @param {?} isDisabled\n  * @return {?}\n  */\n  function (isDisabled) {\n    this.el.nativeElement.disabled = isDisabled;\n  };\n  ValueAccessor.propDecorators = {\n    _handleBlurEvent: [{\n      type: HostListener,\n      args: ['ionBlur', ['$event.target']]\n    }]\n  };\n  return ValueAccessor;\n}();\n/** @type {?} */\nvar setIonicClasses =\n/**\n* @param {?} element\n* @return {?}\n*/\nfunction (element) {\n  raf(\n  /**\n  * @return {?}\n  */\n  function () {\n    /** @type {?} */\n    var input = /** @type {?} */element.nativeElement;\n    /** @type {?} */\n    var classes = getClasses(input);\n    setClasses(input, classes);\n    /** @type {?} */\n    var item = input.closest('ion-item');\n    if (item) {\n      setClasses(item, classes);\n    }\n  });\n};\n/** @type {?} */\nvar getClasses =\n/**\n* @param {?} element\n* @return {?}\n*/\nfunction (element) {\n  /** @type {?} */\n  var classList = element.classList;\n  /** @type {?} */\n  var classes = [];\n  for (var i = 0; i < classList.length; i++) {\n    /** @type {?} */\n    var item = classList.item(i);\n    if (item !== null && startsWith(item, 'ng-')) {\n      classes.push(\"ion-\" + item.substr(3));\n    }\n  }\n  return classes;\n};\n/** @type {?} */\nvar setClasses =\n/**\n* @param {?} element\n* @param {?} classes\n* @return {?}\n*/\nfunction (element, classes) {\n  /** @type {?} */\n  var classList = element.classList;\n  ['ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine'].forEach(\n  /**\n  * @param {?} c\n  * @return {?}\n  */\n  function (c) {\n    return classList.remove(c);\n  });\n  classes.forEach(\n  /**\n  * @param {?} c\n  * @return {?}\n  */\n  function (c) {\n    return classList.add(c);\n  });\n};\n/** @type {?} */\nvar startsWith =\n/**\n* @param {?} input\n* @param {?} search\n* @return {?}\n*/\nfunction (input, search) {\n  return input.substr(0, search.length) === search;\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar BooleanValueAccessor = /** @class */function (_super) {\n  __extends(BooleanValueAccessor, _super);\n  function BooleanValueAccessor(el) {\n    return _super.call(this, el) || this;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  BooleanValueAccessor.prototype.writeValue =\n  /**\n  * @param {?} value\n  * @return {?}\n  */\n  function (value) {\n    this.el.nativeElement.checked = this.lastValue = value == null ? false : value;\n    setIonicClasses(this.el);\n  };\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  BooleanValueAccessor.prototype._handleIonChange =\n  /**\n  * @param {?} el\n  * @return {?}\n  */\n  function (el) {\n    this.handleChangeEvent(el, el.checked);\n  };\n  BooleanValueAccessor.decorators = [{\n    type: Directive,\n    args: [{\n      /* tslint:disable-next-line:directive-selector */\n      selector: 'ion-checkbox,ion-toggle',\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: BooleanValueAccessor,\n        multi: true\n      }]\n    }]\n  }];\n  /** @nocollapse */\n  BooleanValueAccessor.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }];\n  };\n  BooleanValueAccessor.propDecorators = {\n    _handleIonChange: [{\n      type: HostListener,\n      args: ['ionChange', ['$event.target']]\n    }]\n  };\n  return BooleanValueAccessor;\n}(ValueAccessor);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NumericValueAccessor = /** @class */function (_super) {\n  __extends(NumericValueAccessor, _super);\n  function NumericValueAccessor(el) {\n    return _super.call(this, el) || this;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  NumericValueAccessor.prototype._handleIonChange =\n  /**\n  * @param {?} el\n  * @return {?}\n  */\n  function (el) {\n    this.handleChangeEvent(el, el.value);\n  };\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  NumericValueAccessor.prototype.registerOnChange =\n  /**\n  * @param {?} fn\n  * @return {?}\n  */\n  function (fn) {\n    _super.prototype.registerOnChange.call(this,\n    /**\n    * @param {?} value\n    * @return {?}\n    */\n    function (value) {\n      fn(value === '' ? null : parseFloat(value));\n    });\n  };\n  NumericValueAccessor.decorators = [{\n    type: Directive,\n    args: [{\n      /* tslint:disable-next-line:directive-selector */\n      selector: 'ion-input[type=number]',\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: NumericValueAccessor,\n        multi: true\n      }]\n    }]\n  }];\n  /** @nocollapse */\n  NumericValueAccessor.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }];\n  };\n  NumericValueAccessor.propDecorators = {\n    _handleIonChange: [{\n      type: HostListener,\n      args: ['ionChange', ['$event.target']]\n    }]\n  };\n  return NumericValueAccessor;\n}(ValueAccessor);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar RadioValueAccessor = /** @class */function (_super) {\n  __extends(RadioValueAccessor, _super);\n  function RadioValueAccessor(el) {\n    return _super.call(this, el) || this;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  RadioValueAccessor.prototype._handleIonSelect =\n  /**\n  * @param {?} el\n  * @return {?}\n  */\n  function (el) {\n    this.handleChangeEvent(el, el.checked);\n  };\n  RadioValueAccessor.decorators = [{\n    type: Directive,\n    args: [{\n      /* tslint:disable-next-line:directive-selector */\n      selector: 'ion-radio',\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: RadioValueAccessor,\n        multi: true\n      }]\n    }]\n  }];\n  /** @nocollapse */\n  RadioValueAccessor.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }];\n  };\n  RadioValueAccessor.propDecorators = {\n    _handleIonSelect: [{\n      type: HostListener,\n      args: ['ionSelect', ['$event.target']]\n    }]\n  };\n  return RadioValueAccessor;\n}(ValueAccessor);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar SelectValueAccessor = /** @class */function (_super) {\n  __extends(SelectValueAccessor, _super);\n  function SelectValueAccessor(el) {\n    return _super.call(this, el) || this;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  SelectValueAccessor.prototype._handleChangeEvent =\n  /**\n  * @param {?} el\n  * @return {?}\n  */\n  function (el) {\n    this.handleChangeEvent(el, el.value);\n  };\n  SelectValueAccessor.decorators = [{\n    type: Directive,\n    args: [{\n      /* tslint:disable-next-line:directive-selector */\n      selector: 'ion-range, ion-select, ion-radio-group, ion-segment, ion-datetime',\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: SelectValueAccessor,\n        multi: true\n      }]\n    }]\n  }];\n  /** @nocollapse */\n  SelectValueAccessor.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }];\n  };\n  SelectValueAccessor.propDecorators = {\n    _handleChangeEvent: [{\n      type: HostListener,\n      args: ['ionChange', ['$event.target']]\n    }]\n  };\n  return SelectValueAccessor;\n}(ValueAccessor);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar TextValueAccessor = /** @class */function (_super) {\n  __extends(TextValueAccessor, _super);\n  function TextValueAccessor(el) {\n    return _super.call(this, el) || this;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n  TextValueAccessor.prototype._handleInputEvent =\n  /**\n  * @param {?} el\n  * @return {?}\n  */\n  function (el) {\n    this.handleChangeEvent(el, el.value);\n  };\n  TextValueAccessor.decorators = [{\n    type: Directive,\n    args: [{\n      /* tslint:disable-next-line:directive-selector */\n      selector: 'ion-input:not([type=number]),ion-textarea,ion-searchbar',\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: TextValueAccessor,\n        multi: true\n      }]\n    }]\n  }];\n  /** @nocollapse */\n  TextValueAccessor.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }];\n  };\n  TextValueAccessor.propDecorators = {\n    _handleInputEvent: [{\n      type: HostListener,\n      args: ['ionChange', ['$event.target']]\n    }]\n  };\n  return TextValueAccessor;\n}(ValueAccessor);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Platform = /** @class */function () {\n  function Platform(doc, zone) {\n    var _this = this;\n    this.doc = doc;\n    /**\n     * @hidden\n     */\n    this.backButton = /** @type {?} */new Subject();\n    /**\n     * The pause event emits when the native platform puts the application\n     * into the background, typically when the user switches to a different\n     * application. This event would emit when a Cordova app is put into\n     * the background, however, it would not fire on a standard web browser.\n     */\n    this.pause = new Subject();\n    /**\n     * The resume event emits when the native platform pulls the application\n     * out from the background. This event would emit when a Cordova app comes\n     * out from the background, however, it would not fire on a standard web browser.\n     */\n    this.resume = new Subject();\n    /**\n     * The resize event emits when the browser window has changed dimensions. This\n     * could be from a browser window being physically resized, or from a device\n     * changing orientation.\n     */\n    this.resize = new Subject();\n    zone.run(\n    /**\n    * @return {?}\n    */\n    function () {\n      _this.win = doc.defaultView;\n      _this.backButton.subscribeWithPriority =\n      /**\n      * @param {?} priority\n      * @param {?} callback\n      * @return {?}\n      */\n      function (priority, callback) {\n        return this.subscribe(\n        /**\n        * @param {?} ev\n        * @return {?}\n        */\n        function (ev) {\n          return ev.register(priority,\n          /**\n          * @return {?}\n          */\n          function () {\n            return zone.run(callback);\n          });\n        });\n      };\n      proxyEvent(_this.pause, doc, 'pause');\n      proxyEvent(_this.resume, doc, 'resume');\n      proxyEvent(_this.backButton, doc, 'ionBackButton');\n      proxyEvent(_this.resize, _this.win, 'resize');\n      /** @type {?} */\n      var readyResolve;\n      _this._readyPromise = new Promise(\n      /**\n      * @param {?} res\n      * @return {?}\n      */\n      function (res) {\n        readyResolve = res;\n      });\n      if (_this.win && _this.win['cordova']) {\n        doc.addEventListener('deviceready',\n        /**\n        * @return {?}\n        */\n        function () {\n          readyResolve('cordova');\n        }, {\n          once: true\n        });\n      } else {\n        /** @type {?} */readyResolve('dom');\n      }\n    });\n  }\n  /**\n   * @returns returns true/false based on platform.\n   * @description\n   * Depending on the platform the user is on, `is(platformName)` will\n   * return `true` or `false`. Note that the same app can return `true`\n   * for more than one platform name. For example, an app running from\n   * an iPad would return `true` for the platform names: `mobile`,\n   * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n   * from Cordova then `cordova` would be true, and if it was running\n   * from a web browser on the iPad then `mobileweb` would be `true`.\n   *\n   * ```\n   * import { Platform } from 'ionic-angular';\n   *\n   * @Component({...})\n   * export MyPage {\n   *   constructor(public platform: Platform) {\n   *     if (this.platform.is('ios')) {\n   *       // This will only print when on iOS\n   *       console.log('I am an iOS device!');\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * | Platform Name   | Description                        |\n   * |-----------------|------------------------------------|\n   * | android         | on a device running Android.       |\n   * | cordova         | on a device running Cordova.       |\n   * | ios             | on a device running iOS.           |\n   * | ipad            | on an iPad device.                 |\n   * | iphone          | on an iPhone device.               |\n   * | phablet         | on a phablet device.               |\n   * | tablet          | on a tablet device.                |\n   * | electron        | in Electron on a desktop device.   |\n   * | pwa             | as a PWA app.                      |\n   * | mobile          | on a mobile device.                |\n   * | mobileweb       | on a mobile device in a browser.   |\n   * | desktop         | on a desktop device.               |\n   * | hybrid          | is a cordova or capacitor app.     |\n   *\n   */\n  /**\n   * \\@description\n   * Depending on the platform the user is on, `is(platformName)` will\n   * return `true` or `false`. Note that the same app can return `true`\n   * for more than one platform name. For example, an app running from\n   * an iPad would return `true` for the platform names: `mobile`,\n   * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n   * from Cordova then `cordova` would be true, and if it was running\n   * from a web browser on the iPad then `mobileweb` would be `true`.\n   *\n   * ```\n   * import { Platform } from 'ionic-angular';\n   *\n   * \\@Component({...})\n   * export MyPage {\n   *   constructor(public platform: Platform) {\n   *     if (this.platform.is('ios')) {\n   *       // This will only print when on iOS\n   *       console.log('I am an iOS device!');\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * | Platform Name   | Description                        |\n   * |-----------------|------------------------------------|\n   * | android         | on a device running Android.       |\n   * | cordova         | on a device running Cordova.       |\n   * | ios             | on a device running iOS.           |\n   * | ipad            | on an iPad device.                 |\n   * | iphone          | on an iPhone device.               |\n   * | phablet         | on a phablet device.               |\n   * | tablet          | on a tablet device.                |\n   * | electron        | in Electron on a desktop device.   |\n   * | pwa             | as a PWA app.                      |\n   * | mobile          | on a mobile device.                |\n   * | mobileweb       | on a mobile device in a browser.   |\n   * | desktop         | on a desktop device.               |\n   * | hybrid          | is a cordova or capacitor app.     |\n   *\n   * @param {?} platformName\n   * @return {?} returns true/false based on platform.\n   */\n  Platform.prototype.is =\n  /**\n  * \\@description\n  * Depending on the platform the user is on, `is(platformName)` will\n  * return `true` or `false`. Note that the same app can return `true`\n  * for more than one platform name. For example, an app running from\n  * an iPad would return `true` for the platform names: `mobile`,\n  * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n  * from Cordova then `cordova` would be true, and if it was running\n  * from a web browser on the iPad then `mobileweb` would be `true`.\n  *\n  * ```\n  * import { Platform } from 'ionic-angular';\n  *\n  * \\@Component({...})\n  * export MyPage {\n  *   constructor(public platform: Platform) {\n  *     if (this.platform.is('ios')) {\n  *       // This will only print when on iOS\n  *       console.log('I am an iOS device!');\n  *     }\n  *   }\n  * }\n  * ```\n  *\n  * | Platform Name   | Description                        |\n  * |-----------------|------------------------------------|\n  * | android         | on a device running Android.       |\n  * | cordova         | on a device running Cordova.       |\n  * | ios             | on a device running iOS.           |\n  * | ipad            | on an iPad device.                 |\n  * | iphone          | on an iPhone device.               |\n  * | phablet         | on a phablet device.               |\n  * | tablet          | on a tablet device.                |\n  * | electron        | in Electron on a desktop device.   |\n  * | pwa             | as a PWA app.                      |\n  * | mobile          | on a mobile device.                |\n  * | mobileweb       | on a mobile device in a browser.   |\n  * | desktop         | on a desktop device.               |\n  * | hybrid          | is a cordova or capacitor app.     |\n  *\n  * @param {?} platformName\n  * @return {?} returns true/false based on platform.\n  */\n  function (platformName) {\n    return isPlatform(this.win, platformName);\n  };\n  /**\n   * @returns the array of platforms\n   * @description\n   * Depending on what device you are on, `platforms` can return multiple values.\n   * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n   * it would return `mobile`, `ios`, and `iphone`.\n   *\n   * ```\n   * import { Platform } from 'ionic-angular';\n   *\n   * @Component({...})\n   * export MyPage {\n   *   constructor(public platform: Platform) {\n   *     // This will print an array of the current platforms\n   *     console.log(this.platform.platforms());\n   *   }\n   * }\n   * ```\n   */\n  /**\n   * \\@description\n   * Depending on what device you are on, `platforms` can return multiple values.\n   * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n   * it would return `mobile`, `ios`, and `iphone`.\n   *\n   * ```\n   * import { Platform } from 'ionic-angular';\n   *\n   * \\@Component({...})\n   * export MyPage {\n   *   constructor(public platform: Platform) {\n   *     // This will print an array of the current platforms\n   *     console.log(this.platform.platforms());\n   *   }\n   * }\n   * ```\n   * @return {?} the array of platforms\n   */\n  Platform.prototype.platforms =\n  /**\n  * \\@description\n  * Depending on what device you are on, `platforms` can return multiple values.\n  * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n  * it would return `mobile`, `ios`, and `iphone`.\n  *\n  * ```\n  * import { Platform } from 'ionic-angular';\n  *\n  * \\@Component({...})\n  * export MyPage {\n  *   constructor(public platform: Platform) {\n  *     // This will print an array of the current platforms\n  *     console.log(this.platform.platforms());\n  *   }\n  * }\n  * ```\n  * @return {?} the array of platforms\n  */\n  function () {\n    return getPlatforms(this.win);\n  };\n  /**\n   * Returns a promise when the platform is ready and native functionality\n   * can be called. If the app is running from within a web browser, then\n   * the promise will resolve when the DOM is ready. When the app is running\n   * from an application engine such as Cordova, then the promise will\n   * resolve when Cordova triggers the `deviceready` event.\n   *\n   * The resolved value is the `readySource`, which states which platform\n   * ready was used. For example, when Cordova is ready, the resolved ready\n   * source is `cordova`. The default ready source value will be `dom`. The\n   * `readySource` is useful if different logic should run depending on the\n   * platform the app is running from. For example, only Cordova can execute\n   * the status bar plugin, so the web should not run status bar plugin logic.\n   *\n   * ```\n   * import { Component } from '@angular/core';\n   * import { Platform } from 'ionic-angular';\n   *\n   * @Component({...})\n   * export MyApp {\n   *   constructor(public platform: Platform) {\n   *     this.platform.ready().then((readySource) => {\n   *       console.log('Platform ready from', readySource);\n   *       // Platform now ready, execute any required native code\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  /**\n   * Returns a promise when the platform is ready and native functionality\n   * can be called. If the app is running from within a web browser, then\n   * the promise will resolve when the DOM is ready. When the app is running\n   * from an application engine such as Cordova, then the promise will\n   * resolve when Cordova triggers the `deviceready` event.\n   *\n   * The resolved value is the `readySource`, which states which platform\n   * ready was used. For example, when Cordova is ready, the resolved ready\n   * source is `cordova`. The default ready source value will be `dom`. The\n   * `readySource` is useful if different logic should run depending on the\n   * platform the app is running from. For example, only Cordova can execute\n   * the status bar plugin, so the web should not run status bar plugin logic.\n   *\n   * ```\n   * import { Component } from '\\@angular/core';\n   * import { Platform } from 'ionic-angular';\n   *\n   * \\@Component({...})\n   * export MyApp {\n   *   constructor(public platform: Platform) {\n   *     this.platform.ready().then((readySource) => {\n   *       console.log('Platform ready from', readySource);\n   *       // Platform now ready, execute any required native code\n   *     });\n   *   }\n   * }\n   * ```\n   * @return {?}\n   */\n  Platform.prototype.ready =\n  /**\n  * Returns a promise when the platform is ready and native functionality\n  * can be called. If the app is running from within a web browser, then\n  * the promise will resolve when the DOM is ready. When the app is running\n  * from an application engine such as Cordova, then the promise will\n  * resolve when Cordova triggers the `deviceready` event.\n  *\n  * The resolved value is the `readySource`, which states which platform\n  * ready was used. For example, when Cordova is ready, the resolved ready\n  * source is `cordova`. The default ready source value will be `dom`. The\n  * `readySource` is useful if different logic should run depending on the\n  * platform the app is running from. For example, only Cordova can execute\n  * the status bar plugin, so the web should not run status bar plugin logic.\n  *\n  * ```\n  * import { Component } from '\\@angular/core';\n  * import { Platform } from 'ionic-angular';\n  *\n  * \\@Component({...})\n  * export MyApp {\n  *   constructor(public platform: Platform) {\n  *     this.platform.ready().then((readySource) => {\n  *       console.log('Platform ready from', readySource);\n  *       // Platform now ready, execute any required native code\n  *     });\n  *   }\n  * }\n  * ```\n  * @return {?}\n  */\n  function () {\n    return this._readyPromise;\n  };\n  Object.defineProperty(Platform.prototype, \"isRTL\", {\n    /**\n     * Returns if this app is using right-to-left language direction or not.\n     * We recommend the app's `index.html` file already has the correct `dir`\n     * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n     */\n    get:\n    /**\n    * Returns if this app is using right-to-left language direction or not.\n    * We recommend the app's `index.html` file already has the correct `dir`\n    * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n    * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n    * @return {?}\n    */\n    function () {\n      return this.doc.dir === 'rtl';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Get the query string parameter\n   */\n  /**\n   * Get the query string parameter\n   * @param {?} key\n   * @return {?}\n   */\n  Platform.prototype.getQueryParam =\n  /**\n  * Get the query string parameter\n  * @param {?} key\n  * @return {?}\n  */\n  function (key) {\n    return readQueryParam(this.win.location.href, key);\n  };\n  /**\n   * Returns `true` if the app is in landscape mode.\n   */\n  /**\n   * Returns `true` if the app is in landscape mode.\n   * @return {?}\n   */\n  Platform.prototype.isLandscape =\n  /**\n  * Returns `true` if the app is in landscape mode.\n  * @return {?}\n  */\n  function () {\n    return !this.isPortrait();\n  };\n  /**\n   * Returns `true` if the app is in portait mode.\n   */\n  /**\n   * Returns `true` if the app is in portait mode.\n   * @return {?}\n   */\n  Platform.prototype.isPortrait =\n  /**\n  * Returns `true` if the app is in portait mode.\n  * @return {?}\n  */\n  function () {\n    return this.win.matchMedia && this.win.matchMedia('(orientation: portrait)').matches;\n  };\n  /**\n   * @param {?} expression\n   * @return {?}\n   */\n  Platform.prototype.testUserAgent =\n  /**\n  * @param {?} expression\n  * @return {?}\n  */\n  function (expression) {\n    /** @type {?} */\n    var nav = this.win.navigator;\n    return !!(nav && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);\n  };\n  /**\n   * Get the current url.\n   */\n  /**\n   * Get the current url.\n   * @return {?}\n   */\n  Platform.prototype.url =\n  /**\n  * Get the current url.\n  * @return {?}\n  */\n  function () {\n    return this.win.location.href;\n  };\n  /**\n   * Gets the width of the platform's viewport using `window.innerWidth`.\n   */\n  /**\n   * Gets the width of the platform's viewport using `window.innerWidth`.\n   * @return {?}\n   */\n  Platform.prototype.width =\n  /**\n  * Gets the width of the platform's viewport using `window.innerWidth`.\n  * @return {?}\n  */\n  function () {\n    return this.win.innerWidth;\n  };\n  /**\n   * Gets the height of the platform's viewport using `window.innerHeight`.\n   */\n  /**\n   * Gets the height of the platform's viewport using `window.innerHeight`.\n   * @return {?}\n   */\n  Platform.prototype.height =\n  /**\n  * Gets the height of the platform's viewport using `window.innerHeight`.\n  * @return {?}\n  */\n  function () {\n    return this.win.innerHeight;\n  };\n  Platform.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  Platform.ctorParameters = function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: NgZone\n    }];\n  };\n  /** @nocollapse */\n  Platform.ngInjectableDef = defineInjectable({\n    factory: function Platform_Factory() {\n      return new Platform(inject(DOCUMENT), inject(NgZone));\n    },\n    token: Platform,\n    providedIn: \"root\"\n  });\n  return Platform;\n}();\n/** @type {?} */\nvar readQueryParam =\n/**\n* @param {?} url\n* @param {?} key\n* @return {?}\n*/\nfunction (url, key) {\n  key = key.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n  /** @type {?} */\n  var regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n  /** @type {?} */\n  var results = regex.exec(url);\n  return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n};\n/** @type {?} */\nvar proxyEvent =\n/**\n* @template T\n* @param {?} emitter\n* @param {?} el\n* @param {?} eventName\n* @return {?}\n*/\nfunction (emitter, el, eventName) {\n  if ( /** @type {?} */el) {\n    el.addEventListener(eventName,\n    /**\n    * @param {?} ev\n    * @return {?}\n    */\n    function (ev) {\n      // ?? cordova might emit \"null\" events\n      emitter.next(ev != null ? /** @type {?} */ /** @type {?} */ev.detail : undefined);\n    });\n  }\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NavController = /** @class */function () {\n  function NavController(platform, location, serializer, router) {\n    var _this = this;\n    this.location = location;\n    this.serializer = serializer;\n    this.router = router;\n    this.direction = DEFAULT_DIRECTION;\n    this.animated = DEFAULT_ANIMATED;\n    this.guessDirection = 'forward';\n    this.lastNavId = -1;\n    // Subscribe to router events to detect direction\n    if (router) {\n      router.events.subscribe(\n      /**\n      * @param {?} ev\n      * @return {?}\n      */\n      function (ev) {\n        if (ev instanceof NavigationStart) {\n          /** @type {?} */\n          var id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\n          _this.guessDirection = id < _this.lastNavId ? 'back' : 'forward';\n          _this.guessAnimation = !ev.restoredState ? _this.guessDirection : undefined;\n          _this.lastNavId = _this.guessDirection === 'forward' ? ev.id : id;\n        }\n      });\n    }\n    // Subscribe to backButton events\n    platform.backButton.subscribeWithPriority(0,\n    /**\n    * @return {?}\n    */\n    function () {\n      return _this.pop();\n    });\n  }\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n   *\n   * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n   * and that it will show a \"forward\" animation by default.\n   *\n   * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n   * ```\n   */\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n   *\n   * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n   * and that it will show a \"forward\" animation by default.\n   *\n   * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n   * ```\n   * @param {?} url\n   * @param {?=} options\n   * @return {?}\n   */\n  NavController.prototype.navigateForward =\n  /**\n  * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n  * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n  *\n  * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n  * and that it will show a \"forward\" animation by default.\n  *\n  * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n  *\n  * ```html\n  * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n  * ```\n  * @param {?} url\n  * @param {?=} options\n  * @return {?}\n  */\n  function (url, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.setDirection('forward', options.animated, options.animationDirection);\n    return this.navigate(url, options);\n  };\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling:\n   *\n   * ```ts\n   * this.navController.setDirection('back');\n   * this.router.navigateByUrl(path);\n   * ```\n   *\n   * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n   * and that it will show a \"back\" animation by default.\n   *\n   * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n   * ```\n   */\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling:\n   *\n   * ```ts\n   * this.navController.setDirection('back');\n   * this.router.navigateByUrl(path);\n   * ```\n   *\n   * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n   * and that it will show a \"back\" animation by default.\n   *\n   * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n   * ```\n   * @param {?} url\n   * @param {?=} options\n   * @return {?}\n   */\n  NavController.prototype.navigateBack =\n  /**\n  * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n  * it's equivalent to calling:\n  *\n  * ```ts\n  * this.navController.setDirection('back');\n  * this.router.navigateByUrl(path);\n  * ```\n  *\n  * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n  * and that it will show a \"back\" animation by default.\n  *\n  * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n  *\n  * ```html\n  * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n  * ```\n  * @param {?} url\n  * @param {?=} options\n  * @return {?}\n  */\n  function (url, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.setDirection('back', options.animated, options.animationDirection);\n    return this.navigate(url, options);\n  };\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling:\n   *\n   * ```ts\n   * this.navController.setDirection('root');\n   * this.router.navigateByUrl(path);\n   * ```\n   *\n   * Going **root** means that all existing pages in the stack will be removed,\n   * and the navigated page will become the single page in the stack.\n   *\n   * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n   * ```\n   */\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling:\n   *\n   * ```ts\n   * this.navController.setDirection('root');\n   * this.router.navigateByUrl(path);\n   * ```\n   *\n   * Going **root** means that all existing pages in the stack will be removed,\n   * and the navigated page will become the single page in the stack.\n   *\n   * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n   * ```\n   * @param {?} url\n   * @param {?=} options\n   * @return {?}\n   */\n  NavController.prototype.navigateRoot =\n  /**\n  * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n  * it's equivalent to calling:\n  *\n  * ```ts\n  * this.navController.setDirection('root');\n  * this.router.navigateByUrl(path);\n  * ```\n  *\n  * Going **root** means that all existing pages in the stack will be removed,\n  * and the navigated page will become the single page in the stack.\n  *\n  * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n  *\n  * ```html\n  * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n  * ```\n  * @param {?} url\n  * @param {?=} options\n  * @return {?}\n  */\n  function (url, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.setDirection('root', options.animated, options.animationDirection);\n    return this.navigate(url, options);\n  };\n  /**\n   * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n   * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n   * by default.\n   */\n  /**\n   * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n   * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n   * by default.\n   * @param {?=} options\n   * @return {?}\n   */\n  NavController.prototype.back =\n  /**\n  * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n  * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n  * by default.\n  * @param {?=} options\n  * @return {?}\n  */\n  function (options) {\n    if (options === void 0) {\n      options = {\n        animated: true,\n        animationDirection: 'back'\n      };\n    }\n    this.setDirection('back', options.animated, options.animationDirection);\n    return this.location.back();\n  };\n  /**\n   * This methods goes back in the context of Ionic's stack navigation.\n   *\n   * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n   * This is the recommended way to go back when you are using `ion-router-outlet`.\n   */\n  /**\n   * This methods goes back in the context of Ionic's stack navigation.\n   *\n   * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n   * This is the recommended way to go back when you are using `ion-router-outlet`.\n   * @return {?}\n   */\n  NavController.prototype.pop =\n  /**\n  * This methods goes back in the context of Ionic's stack navigation.\n  *\n  * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n  * This is the recommended way to go back when you are using `ion-router-outlet`.\n  * @return {?}\n  */\n  function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var outlet;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            outlet = this.topOutlet;\n            _a.label = 1;\n          case 1:\n            if (!outlet) return [3 /*break*/, 3];\n            return [4 /*yield*/, outlet.pop()];\n          case 2:\n            if (_a.sent()) {\n              return [3 /*break*/, 3];\n            } else {\n              outlet = outlet.parentOutlet;\n            }\n            return [3 /*break*/, 1];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * This methods specifies the direction of the next navigation performed by the Angular router.\n   *\n   * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n   *\n   * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n   */\n  /**\n   * This methods specifies the direction of the next navigation performed by the Angular router.\n   *\n   * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n   *\n   * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n   * @param {?} direction\n   * @param {?=} animated\n   * @param {?=} animationDirection\n   * @return {?}\n   */\n  NavController.prototype.setDirection =\n  /**\n  * This methods specifies the direction of the next navigation performed by the Angular router.\n  *\n  * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n  *\n  * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n  * @param {?} direction\n  * @param {?=} animated\n  * @param {?=} animationDirection\n  * @return {?}\n  */\n  function (direction, animated, animationDirection) {\n    this.direction = direction;\n    this.animated = getAnimation(direction, animated, animationDirection);\n  };\n  /**\n   * @internal\n   */\n  /**\n   * \\@internal\n   * @param {?} outlet\n   * @return {?}\n   */\n  NavController.prototype.setTopOutlet =\n  /**\n  * \\@internal\n  * @param {?} outlet\n  * @return {?}\n  */\n  function (outlet) {\n    this.topOutlet = outlet;\n  };\n  /**\n   * @internal\n   */\n  /**\n   * \\@internal\n   * @return {?}\n   */\n  NavController.prototype.consumeTransition =\n  /**\n  * \\@internal\n  * @return {?}\n  */\n  function () {\n    /** @type {?} */\n    var direction = 'root';\n    /** @type {?} */\n    var animation;\n    if (this.direction === 'auto') {\n      direction = this.guessDirection;\n      animation = this.guessAnimation;\n    } else {\n      animation = this.animated;\n      direction = this.direction;\n    }\n    this.direction = DEFAULT_DIRECTION;\n    this.animated = DEFAULT_ANIMATED;\n    return {\n      direction: direction,\n      animation: animation\n    };\n  };\n  /**\n   * @private\n   * @param {?} url\n   * @param {?} options\n   * @return {?}\n   */\n  NavController.prototype.navigate =\n  /**\n  * @private\n  * @param {?} url\n  * @param {?} options\n  * @return {?}\n  */\n  function (url, options) {\n    if (Array.isArray(url)) {\n      return (/** @type {?} */this.router.navigate(url, options)\n      );\n    } else {\n      /**\n       * navigateByUrl ignores any properties that\n       * would change the url, so things like queryParams\n       * would be ignored unless we create a url tree\n       * More Info: https://github.com/angular/angular/issues/18798\n       * @type {?}\n       */\n      var urlTree = this.serializer.parse(url.toString());\n      if (options.queryParams !== undefined) {\n        urlTree.queryParams = __assign({}, options.queryParams);\n      }\n      if (options.fragment !== undefined) {\n        urlTree.fragment = options.fragment;\n      }\n      /**\n       * `navigateByUrl` will still apply `NavigationExtras` properties\n       * that do not modify the url, such as `replaceUrl` which is why\n       * `options` is passed in here.\n       */\n      return (/** @type {?} */this.router.navigateByUrl(urlTree, options)\n      );\n    }\n  };\n  NavController.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  NavController.ctorParameters = function () {\n    return [{\n      type: Platform\n    }, {\n      type: Location\n    }, {\n      type: UrlSerializer\n    }, {\n      type: Router,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  };\n  /** @nocollapse */\n  NavController.ngInjectableDef = defineInjectable({\n    factory: function NavController_Factory() {\n      return new NavController(inject(Platform), inject(Location), inject(UrlSerializer), inject(Router, 8));\n    },\n    token: NavController,\n    providedIn: \"root\"\n  });\n  return NavController;\n}();\n/** @type {?} */\nvar getAnimation =\n/**\n* @param {?} direction\n* @param {?} animated\n* @param {?} animationDirection\n* @return {?}\n*/\nfunction (direction, animated, animationDirection) {\n  if (animated === false) {\n    return undefined;\n  }\n  if (animationDirection !== undefined) {\n    return animationDirection;\n  }\n  if (direction === 'forward' || direction === 'back') {\n    return direction;\n  } else if (direction === 'root' && animated === true) {\n    return 'forward';\n  }\n  return undefined;\n};\n/** @type {?} */\nvar DEFAULT_DIRECTION = 'auto';\n/** @type {?} */\nvar DEFAULT_ANIMATED = undefined;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar proxyInputs =\n/**\n* @param {?} Cmp\n* @param {?} inputs\n* @return {?}\n*/\nfunction (Cmp, inputs) {\n  /** @type {?} */\n  var Prototype = Cmp.prototype;\n  inputs.forEach(\n  /**\n  * @param {?} item\n  * @return {?}\n  */\n  function (item) {\n    Object.defineProperty(Prototype, item, {\n      get:\n      /**\n      * @return {?}\n      */\n      function () {\n        return this.el[item];\n      },\n      set:\n      /**\n      * @param {?} val\n      * @return {?}\n      */\n      function (val) {\n        var _this = this;\n        this.z.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this.el[item] = val;\n        });\n      }\n    });\n  });\n};\n/** @type {?} */\nvar proxyMethods =\n/**\n* @param {?} Cmp\n* @param {?} methods\n* @return {?}\n*/\nfunction (Cmp, methods) {\n  /** @type {?} */\n  var Prototype = Cmp.prototype;\n  methods.forEach(\n  /**\n  * @param {?} methodName\n  * @return {?}\n  */\n  function (methodName) {\n    Prototype[methodName] =\n    /**\n    * @return {?}\n    */\n    function () {\n      var _this = this;\n      /** @type {?} */\n      var args = arguments;\n      return this.z.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this.el[methodName].apply(_this.el, args);\n      });\n    };\n  });\n};\n/** @type {?} */\nvar proxyOutputs =\n/**\n* @param {?} instance\n* @param {?} el\n* @param {?} events\n* @return {?}\n*/\nfunction (instance, el, events) {\n  events.forEach(\n  /**\n  * @param {?} eventName\n  * @return {?}\n  */\n  function (eventName) {\n    return instance[eventName] = fromEvent(el, eventName);\n  });\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonApp = /** @class */function () {\n  function IonApp(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonApp.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-app',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>'\n    }]\n  }];\n  /** @nocollapse */\n  IonApp.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonApp;\n}();\nvar IonAvatar = /** @class */function () {\n  function IonAvatar(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonAvatar.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-avatar',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>'\n    }]\n  }];\n  /** @nocollapse */\n  IonAvatar.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonAvatar;\n}();\nvar IonBackButton = /** @class */function () {\n  function IonBackButton(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonBackButton.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-back-button',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'text', 'type']\n    }]\n  }];\n  /** @nocollapse */\n  IonBackButton.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonBackButton;\n}();\nproxyInputs(IonBackButton, ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'text', 'type']);\nvar IonBackdrop = /** @class */function () {\n  function IonBackdrop(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionBackdropTap']);\n  }\n  IonBackdrop.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-backdrop',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['stopPropagation', 'tappable', 'visible']\n    }]\n  }];\n  /** @nocollapse */\n  IonBackdrop.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonBackdrop;\n}();\nproxyInputs(IonBackdrop, ['stopPropagation', 'tappable', 'visible']);\nvar IonBadge = /** @class */function () {\n  function IonBadge(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonBadge.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-badge',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonBadge.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonBadge;\n}();\nproxyInputs(IonBadge, ['color', 'mode']);\nvar IonButton = /** @class */function () {\n  function IonButton(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n  }\n  IonButton.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-button',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type']\n    }]\n  }];\n  /** @nocollapse */\n  IonButton.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonButton;\n}();\nproxyInputs(IonButton, ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'href', 'mode', 'rel', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type']);\nvar IonButtons = /** @class */function () {\n  function IonButtons(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonButtons.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-buttons',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['collapse']\n    }]\n  }];\n  /** @nocollapse */\n  IonButtons.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonButtons;\n}();\nproxyInputs(IonButtons, ['collapse']);\nvar IonCard = /** @class */function () {\n  function IonCard(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonCard.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-card',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'target', 'type']\n    }]\n  }];\n  /** @nocollapse */\n  IonCard.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonCard;\n}();\nproxyInputs(IonCard, ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'target', 'type']);\nvar IonCardContent = /** @class */function () {\n  function IonCardContent(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonCardContent.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-card-content',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonCardContent.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonCardContent;\n}();\nproxyInputs(IonCardContent, ['mode']);\nvar IonCardHeader = /** @class */function () {\n  function IonCardHeader(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonCardHeader.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-card-header',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode', 'translucent']\n    }]\n  }];\n  /** @nocollapse */\n  IonCardHeader.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonCardHeader;\n}();\nproxyInputs(IonCardHeader, ['color', 'mode', 'translucent']);\nvar IonCardSubtitle = /** @class */function () {\n  function IonCardSubtitle(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonCardSubtitle.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-card-subtitle',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonCardSubtitle.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonCardSubtitle;\n}();\nproxyInputs(IonCardSubtitle, ['color', 'mode']);\nvar IonCardTitle = /** @class */function () {\n  function IonCardTitle(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonCardTitle.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-card-title',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonCardTitle.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonCardTitle;\n}();\nproxyInputs(IonCardTitle, ['color', 'mode']);\nvar IonCheckbox = /** @class */function () {\n  function IonCheckbox(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n  }\n  IonCheckbox.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-checkbox',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonCheckbox.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonCheckbox;\n}();\nproxyInputs(IonCheckbox, ['checked', 'color', 'disabled', 'indeterminate', 'mode', 'name', 'value']);\nvar IonChip = /** @class */function () {\n  function IonChip(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonChip.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-chip',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode', 'outline']\n    }]\n  }];\n  /** @nocollapse */\n  IonChip.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonChip;\n}();\nproxyInputs(IonChip, ['color', 'mode', 'outline']);\nvar IonCol = /** @class */function () {\n  function IonCol(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonCol.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-col',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs']\n    }]\n  }];\n  /** @nocollapse */\n  IonCol.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonCol;\n}();\nproxyInputs(IonCol, ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs']);\nvar IonContent = /** @class */function () {\n  function IonContent(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionScrollStart', 'ionScroll', 'ionScrollEnd']);\n  }\n  IonContent.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-content',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY']\n    }]\n  }];\n  /** @nocollapse */\n  IonContent.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonContent;\n}();\nproxyMethods(IonContent, ['getScrollElement', 'scrollToTop', 'scrollToBottom', 'scrollByPoint', 'scrollToPoint']);\nproxyInputs(IonContent, ['color', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY']);\nvar IonDatetime = /** @class */function () {\n  function IonDatetime(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionCancel', 'ionChange', 'ionFocus', 'ionBlur']);\n  }\n  IonDatetime.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-datetime',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['cancelText', 'dayNames', 'dayShortNames', 'dayValues', 'disabled', 'displayFormat', 'doneText', 'hourValues', 'max', 'min', 'minuteValues', 'mode', 'monthNames', 'monthShortNames', 'monthValues', 'name', 'pickerFormat', 'pickerOptions', 'placeholder', 'readonly', 'value', 'yearValues']\n    }]\n  }];\n  /** @nocollapse */\n  IonDatetime.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonDatetime;\n}();\nproxyMethods(IonDatetime, ['open']);\nproxyInputs(IonDatetime, ['cancelText', 'dayNames', 'dayShortNames', 'dayValues', 'disabled', 'displayFormat', 'doneText', 'hourValues', 'max', 'min', 'minuteValues', 'mode', 'monthNames', 'monthShortNames', 'monthValues', 'name', 'pickerFormat', 'pickerOptions', 'placeholder', 'readonly', 'value', 'yearValues']);\nvar IonFab = /** @class */function () {\n  function IonFab(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonFab.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-fab',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['activated', 'edge', 'horizontal', 'vertical']\n    }]\n  }];\n  /** @nocollapse */\n  IonFab.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonFab;\n}();\nproxyMethods(IonFab, ['close']);\nproxyInputs(IonFab, ['activated', 'edge', 'horizontal', 'vertical']);\nvar IonFabButton = /** @class */function () {\n  function IonFabButton(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n  }\n  IonFabButton.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-fab-button',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['activated', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type']\n    }]\n  }];\n  /** @nocollapse */\n  IonFabButton.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonFabButton;\n}();\nproxyInputs(IonFabButton, ['activated', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type']);\nvar IonFabList = /** @class */function () {\n  function IonFabList(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonFabList.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-fab-list',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['activated', 'side']\n    }]\n  }];\n  /** @nocollapse */\n  IonFabList.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonFabList;\n}();\nproxyInputs(IonFabList, ['activated', 'side']);\nvar IonFooter = /** @class */function () {\n  function IonFooter(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonFooter.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-footer',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['mode', 'translucent']\n    }]\n  }];\n  /** @nocollapse */\n  IonFooter.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonFooter;\n}();\nproxyInputs(IonFooter, ['mode', 'translucent']);\nvar IonGrid = /** @class */function () {\n  function IonGrid(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonGrid.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-grid',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['fixed']\n    }]\n  }];\n  /** @nocollapse */\n  IonGrid.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonGrid;\n}();\nproxyInputs(IonGrid, ['fixed']);\nvar IonHeader = /** @class */function () {\n  function IonHeader(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonHeader.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-header',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['collapse', 'mode', 'translucent']\n    }]\n  }];\n  /** @nocollapse */\n  IonHeader.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonHeader;\n}();\nproxyInputs(IonHeader, ['collapse', 'mode', 'translucent']);\nvar IonIcon = /** @class */function () {\n  function IonIcon(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonIcon.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-icon',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['ariaLabel', 'color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'size', 'src']\n    }]\n  }];\n  /** @nocollapse */\n  IonIcon.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonIcon;\n}();\nproxyInputs(IonIcon, ['ariaLabel', 'color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'size', 'src']);\nvar IonImg = /** @class */function () {\n  function IonImg(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionImgWillLoad', 'ionImgDidLoad', 'ionError']);\n  }\n  IonImg.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-img',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['alt', 'src']\n    }]\n  }];\n  /** @nocollapse */\n  IonImg.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonImg;\n}();\nproxyInputs(IonImg, ['alt', 'src']);\nvar IonInfiniteScroll = /** @class */function () {\n  function IonInfiniteScroll(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionInfinite']);\n  }\n  IonInfiniteScroll.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-infinite-scroll',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['disabled', 'position', 'threshold']\n    }]\n  }];\n  /** @nocollapse */\n  IonInfiniteScroll.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonInfiniteScroll;\n}();\nproxyMethods(IonInfiniteScroll, ['complete']);\nproxyInputs(IonInfiniteScroll, ['disabled', 'position', 'threshold']);\nvar IonInfiniteScrollContent = /** @class */function () {\n  function IonInfiniteScrollContent(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonInfiniteScrollContent.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-infinite-scroll-content',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['loadingSpinner', 'loadingText']\n    }]\n  }];\n  /** @nocollapse */\n  IonInfiniteScrollContent.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonInfiniteScrollContent;\n}();\nproxyInputs(IonInfiniteScrollContent, ['loadingSpinner', 'loadingText']);\nvar IonInput = /** @class */function () {\n  function IonInput(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionBlur', 'ionFocus']);\n  }\n  IonInput.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-input',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonInput.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonInput;\n}();\nproxyMethods(IonInput, ['setFocus', 'getInputElement']);\nproxyInputs(IonInput, ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'debounce', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'spellcheck', 'step', 'type', 'value']);\nvar IonItem = /** @class */function () {\n  function IonItem(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonItem.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-item',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['button', 'color', 'detail', 'detailIcon', 'disabled', 'download', 'href', 'lines', 'mode', 'rel', 'routerDirection', 'target', 'type']\n    }]\n  }];\n  /** @nocollapse */\n  IonItem.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonItem;\n}();\nproxyInputs(IonItem, ['button', 'color', 'detail', 'detailIcon', 'disabled', 'download', 'href', 'lines', 'mode', 'rel', 'routerDirection', 'target', 'type']);\nvar IonItemDivider = /** @class */function () {\n  function IonItemDivider(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonItemDivider.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-item-divider',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode', 'sticky']\n    }]\n  }];\n  /** @nocollapse */\n  IonItemDivider.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonItemDivider;\n}();\nproxyInputs(IonItemDivider, ['color', 'mode', 'sticky']);\nvar IonItemGroup = /** @class */function () {\n  function IonItemGroup(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonItemGroup.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-item-group',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>'\n    }]\n  }];\n  /** @nocollapse */\n  IonItemGroup.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonItemGroup;\n}();\nvar IonItemOption = /** @class */function () {\n  function IonItemOption(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonItemOption.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-item-option',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type']\n    }]\n  }];\n  /** @nocollapse */\n  IonItemOption.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonItemOption;\n}();\nproxyInputs(IonItemOption, ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type']);\nvar IonItemOptions = /** @class */function () {\n  function IonItemOptions(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionSwipe']);\n  }\n  IonItemOptions.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-item-options',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['side']\n    }]\n  }];\n  /** @nocollapse */\n  IonItemOptions.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonItemOptions;\n}();\nproxyInputs(IonItemOptions, ['side']);\nvar IonItemSliding = /** @class */function () {\n  function IonItemSliding(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionDrag']);\n  }\n  IonItemSliding.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-item-sliding',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['disabled']\n    }]\n  }];\n  /** @nocollapse */\n  IonItemSliding.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonItemSliding;\n}();\nproxyMethods(IonItemSliding, ['getOpenAmount', 'getSlidingRatio', 'open', 'close', 'closeOpened']);\nproxyInputs(IonItemSliding, ['disabled']);\nvar IonLabel = /** @class */function () {\n  function IonLabel(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonLabel.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-label',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode', 'position']\n    }]\n  }];\n  /** @nocollapse */\n  IonLabel.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonLabel;\n}();\nproxyInputs(IonLabel, ['color', 'mode', 'position']);\nvar IonList = /** @class */function () {\n  function IonList(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonList.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-list',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['inset', 'lines', 'mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonList.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonList;\n}();\nproxyMethods(IonList, ['closeSlidingItems']);\nproxyInputs(IonList, ['inset', 'lines', 'mode']);\nvar IonListHeader = /** @class */function () {\n  function IonListHeader(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonListHeader.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-list-header',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonListHeader.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonListHeader;\n}();\nproxyInputs(IonListHeader, ['color', 'mode']);\nvar IonMenu = /** @class */function () {\n  function IonMenu(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose']);\n  }\n  IonMenu.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-menu',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type']\n    }]\n  }];\n  /** @nocollapse */\n  IonMenu.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonMenu;\n}();\nproxyMethods(IonMenu, ['isOpen', 'isActive', 'open', 'close', 'toggle', 'setOpen']);\nproxyInputs(IonMenu, ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type']);\nvar IonMenuButton = /** @class */function () {\n  function IonMenuButton(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonMenuButton.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-menu-button',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['autoHide', 'color', 'disabled', 'menu', 'type']\n    }]\n  }];\n  /** @nocollapse */\n  IonMenuButton.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonMenuButton;\n}();\nproxyInputs(IonMenuButton, ['autoHide', 'color', 'disabled', 'menu', 'type']);\nvar IonMenuToggle = /** @class */function () {\n  function IonMenuToggle(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonMenuToggle.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-menu-toggle',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['autoHide', 'menu']\n    }]\n  }];\n  /** @nocollapse */\n  IonMenuToggle.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonMenuToggle;\n}();\nproxyInputs(IonMenuToggle, ['autoHide', 'menu']);\nvar IonNav = /** @class */function () {\n  function IonNav(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionNavWillChange', 'ionNavDidChange']);\n  }\n  IonNav.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-nav',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture']\n    }]\n  }];\n  /** @nocollapse */\n  IonNav.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonNav;\n}();\nproxyMethods(IonNav, ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']);\nproxyInputs(IonNav, ['animated', 'animation', 'root', 'rootParams', 'swipeGesture']);\nvar IonNavLink = /** @class */function () {\n  function IonNavLink(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonNavLink.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-nav-link',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['component', 'componentProps', 'routerDirection']\n    }]\n  }];\n  /** @nocollapse */\n  IonNavLink.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonNavLink;\n}();\nproxyInputs(IonNavLink, ['component', 'componentProps', 'routerDirection']);\nvar IonNavPop = /** @class */function () {\n  function IonNavPop(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonNavPop.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-nav-pop',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>'\n    }]\n  }];\n  /** @nocollapse */\n  IonNavPop.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonNavPop;\n}();\nvar IonNavPush = /** @class */function () {\n  function IonNavPush(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonNavPush.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-nav-push',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['component', 'componentProps']\n    }]\n  }];\n  /** @nocollapse */\n  IonNavPush.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonNavPush;\n}();\nproxyInputs(IonNavPush, ['component', 'componentProps']);\nvar IonNavSetRoot = /** @class */function () {\n  function IonNavSetRoot(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonNavSetRoot.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-nav-set-root',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['component', 'componentProps']\n    }]\n  }];\n  /** @nocollapse */\n  IonNavSetRoot.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonNavSetRoot;\n}();\nproxyInputs(IonNavSetRoot, ['component', 'componentProps']);\nvar IonNote = /** @class */function () {\n  function IonNote(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonNote.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-note',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonNote.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonNote;\n}();\nproxyInputs(IonNote, ['color', 'mode']);\nvar IonProgressBar = /** @class */function () {\n  function IonProgressBar(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonProgressBar.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-progress-bar',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['buffer', 'color', 'mode', 'reversed', 'type', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonProgressBar.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonProgressBar;\n}();\nproxyInputs(IonProgressBar, ['buffer', 'color', 'mode', 'reversed', 'type', 'value']);\nvar IonRadio = /** @class */function () {\n  function IonRadio(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionSelect', 'ionFocus', 'ionBlur']);\n  }\n  IonRadio.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-radio',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonRadio.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonRadio;\n}();\nproxyInputs(IonRadio, ['checked', 'color', 'disabled', 'mode', 'name', 'value']);\nvar IonRadioGroup = /** @class */function () {\n  function IonRadioGroup(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange']);\n  }\n  IonRadioGroup.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-radio-group',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['allowEmptySelection', 'name', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonRadioGroup.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonRadioGroup;\n}();\nproxyInputs(IonRadioGroup, ['allowEmptySelection', 'name', 'value']);\nvar IonRange = /** @class */function () {\n  function IonRange(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n  }\n  IonRange.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-range',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'snaps', 'step', 'ticks', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonRange.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonRange;\n}();\nproxyInputs(IonRange, ['color', 'debounce', 'disabled', 'dualKnobs', 'max', 'min', 'mode', 'name', 'pin', 'snaps', 'step', 'ticks', 'value']);\nvar IonRefresher = /** @class */function () {\n  function IonRefresher(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionRefresh', 'ionPull', 'ionStart']);\n  }\n  IonRefresher.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-refresher',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration']\n    }]\n  }];\n  /** @nocollapse */\n  IonRefresher.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonRefresher;\n}();\nproxyMethods(IonRefresher, ['complete', 'cancel', 'getProgress']);\nproxyInputs(IonRefresher, ['closeDuration', 'disabled', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration']);\nvar IonRefresherContent = /** @class */function () {\n  function IonRefresherContent(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonRefresherContent.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-refresher-content',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']\n    }]\n  }];\n  /** @nocollapse */\n  IonRefresherContent.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonRefresherContent;\n}();\nproxyInputs(IonRefresherContent, ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']);\nvar IonReorder = /** @class */function () {\n  function IonReorder(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonReorder.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-reorder',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>'\n    }]\n  }];\n  /** @nocollapse */\n  IonReorder.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonReorder;\n}();\nvar IonReorderGroup = /** @class */function () {\n  function IonReorderGroup(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionItemReorder']);\n  }\n  IonReorderGroup.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-reorder-group',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['disabled']\n    }]\n  }];\n  /** @nocollapse */\n  IonReorderGroup.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonReorderGroup;\n}();\nproxyMethods(IonReorderGroup, ['complete']);\nproxyInputs(IonReorderGroup, ['disabled']);\nvar IonRippleEffect = /** @class */function () {\n  function IonRippleEffect(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonRippleEffect.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-ripple-effect',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['type']\n    }]\n  }];\n  /** @nocollapse */\n  IonRippleEffect.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonRippleEffect;\n}();\nproxyMethods(IonRippleEffect, ['addRipple']);\nproxyInputs(IonRippleEffect, ['type']);\nvar IonRow = /** @class */function () {\n  function IonRow(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonRow.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-row',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>'\n    }]\n  }];\n  /** @nocollapse */\n  IonRow.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonRow;\n}();\nvar IonSearchbar = /** @class */function () {\n  function IonSearchbar(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus']);\n  }\n  IonSearchbar.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-searchbar',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'spellcheck', 'type', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonSearchbar.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSearchbar;\n}();\nproxyMethods(IonSearchbar, ['setFocus', 'getInputElement']);\nproxyInputs(IonSearchbar, ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'inputmode', 'mode', 'placeholder', 'searchIcon', 'showCancelButton', 'spellcheck', 'type', 'value']);\nvar IonSegment = /** @class */function () {\n  function IonSegment(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange']);\n  }\n  IonSegment.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-segment',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'disabled', 'mode', 'scrollable', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonSegment.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSegment;\n}();\nproxyInputs(IonSegment, ['color', 'disabled', 'mode', 'scrollable', 'value']);\nvar IonSegmentButton = /** @class */function () {\n  function IonSegmentButton(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionSelect']);\n  }\n  IonSegmentButton.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-segment-button',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['checked', 'disabled', 'layout', 'mode', 'type', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonSegmentButton.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSegmentButton;\n}();\nproxyInputs(IonSegmentButton, ['checked', 'disabled', 'layout', 'mode', 'type', 'value']);\nvar IonSelect = /** @class */function () {\n  function IonSelect(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionCancel', 'ionFocus', 'ionBlur']);\n  }\n  IonSelect.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-select',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonSelect.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSelect;\n}();\nproxyMethods(IonSelect, ['open']);\nproxyInputs(IonSelect, ['cancelText', 'compareWith', 'disabled', 'interface', 'interfaceOptions', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'value']);\nvar IonSelectOption = /** @class */function () {\n  function IonSelectOption(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonSelectOption.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-select-option',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['disabled', 'selected', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonSelectOption.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSelectOption;\n}();\nproxyInputs(IonSelectOption, ['disabled', 'selected', 'value']);\nvar IonSkeletonText = /** @class */function () {\n  function IonSkeletonText(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonSkeletonText.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-skeleton-text',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['animated', 'width']\n    }]\n  }];\n  /** @nocollapse */\n  IonSkeletonText.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSkeletonText;\n}();\nproxyInputs(IonSkeletonText, ['animated', 'width']);\nvar IonSlide = /** @class */function () {\n  function IonSlide(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonSlide.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-slide',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>'\n    }]\n  }];\n  /** @nocollapse */\n  IonSlide.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSlide;\n}();\nvar IonSlides = /** @class */function () {\n  function IonSlides(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionSlidesDidLoad', 'ionSlideTap', 'ionSlideDoubleTap', 'ionSlideWillChange', 'ionSlideDidChange', 'ionSlideNextStart', 'ionSlidePrevStart', 'ionSlideNextEnd', 'ionSlidePrevEnd', 'ionSlideTransitionStart', 'ionSlideTransitionEnd', 'ionSlideDrag', 'ionSlideReachStart', 'ionSlideReachEnd', 'ionSlideTouchStart', 'ionSlideTouchEnd']);\n  }\n  IonSlides.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-slides',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['mode', 'options', 'pager', 'scrollbar']\n    }]\n  }];\n  /** @nocollapse */\n  IonSlides.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSlides;\n}();\nproxyMethods(IonSlides, ['update', 'updateAutoHeight', 'slideTo', 'slideNext', 'slidePrev', 'getActiveIndex', 'getPreviousIndex', 'length', 'isEnd', 'isBeginning', 'startAutoplay', 'stopAutoplay', 'lockSwipeToNext', 'lockSwipeToPrev', 'lockSwipes', 'getSwiper']);\nproxyInputs(IonSlides, ['mode', 'options', 'pager', 'scrollbar']);\nvar IonSpinner = /** @class */function () {\n  function IonSpinner(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonSpinner.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-spinner',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'duration', 'name', 'paused']\n    }]\n  }];\n  /** @nocollapse */\n  IonSpinner.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSpinner;\n}();\nproxyInputs(IonSpinner, ['color', 'duration', 'name', 'paused']);\nvar IonSplitPane = /** @class */function () {\n  function IonSplitPane(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionSplitPaneVisible']);\n  }\n  IonSplitPane.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-split-pane',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['contentId', 'disabled', 'when']\n    }]\n  }];\n  /** @nocollapse */\n  IonSplitPane.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonSplitPane;\n}();\nproxyInputs(IonSplitPane, ['contentId', 'disabled', 'when']);\nvar IonTabBar = /** @class */function () {\n  function IonTabBar(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonTabBar.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-tab-bar',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode', 'selectedTab', 'translucent']\n    }]\n  }];\n  /** @nocollapse */\n  IonTabBar.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonTabBar;\n}();\nproxyInputs(IonTabBar, ['color', 'mode', 'selectedTab', 'translucent']);\nvar IonTabButton = /** @class */function () {\n  function IonTabButton(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonTabButton.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-tab-button',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target']\n    }]\n  }];\n  /** @nocollapse */\n  IonTabButton.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonTabButton;\n}();\nproxyInputs(IonTabButton, ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target']);\nvar IonText = /** @class */function () {\n  function IonText(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonText.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-text',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonText.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonText;\n}();\nproxyInputs(IonText, ['color', 'mode']);\nvar IonTextarea = /** @class */function () {\n  function IonTextarea(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionInput', 'ionBlur', 'ionFocus']);\n  }\n  IonTextarea.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-textarea',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap']\n    }]\n  }];\n  /** @nocollapse */\n  IonTextarea.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonTextarea;\n}();\nproxyMethods(IonTextarea, ['setFocus', 'getInputElement']);\nproxyInputs(IonTextarea, ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'debounce', 'disabled', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'spellcheck', 'value', 'wrap']);\nvar IonThumbnail = /** @class */function () {\n  function IonThumbnail(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonThumbnail.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-thumbnail',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>'\n    }]\n  }];\n  /** @nocollapse */\n  IonThumbnail.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonThumbnail;\n}();\nvar IonTitle = /** @class */function () {\n  function IonTitle(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonTitle.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-title',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'size']\n    }]\n  }];\n  /** @nocollapse */\n  IonTitle.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonTitle;\n}();\nproxyInputs(IonTitle, ['color', 'size']);\nvar IonToggle = /** @class */function () {\n  function IonToggle(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n  }\n  IonToggle.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-toggle',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['checked', 'color', 'disabled', 'mode', 'name', 'value']\n    }]\n  }];\n  /** @nocollapse */\n  IonToggle.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonToggle;\n}();\nproxyInputs(IonToggle, ['checked', 'color', 'disabled', 'mode', 'name', 'value']);\nvar IonToolbar = /** @class */function () {\n  function IonToolbar(c, r, z) {\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  }\n  IonToolbar.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-toolbar',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      inputs: ['color', 'mode']\n    }]\n  }];\n  /** @nocollapse */\n  IonToolbar.ctorParameters = function () {\n    return [{\n      type: ChangeDetectorRef\n    }, {\n      type: ElementRef\n    }, {\n      type: NgZone\n    }];\n  };\n  return IonToolbar;\n}();\nproxyInputs(IonToolbar, ['color', 'mode']);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Config = /** @class */function () {\n  function Config() {}\n  /**\n   * @param {?} key\n   * @param {?=} fallback\n   * @return {?}\n   */\n  Config.prototype.get =\n  /**\n  * @param {?} key\n  * @param {?=} fallback\n  * @return {?}\n  */\n  function (key, fallback) {\n    /** @type {?} */\n    var c = getConfig();\n    if (c) {\n      return c.get(key, fallback);\n    }\n    return null;\n  };\n  /**\n   * @param {?} key\n   * @param {?=} fallback\n   * @return {?}\n   */\n  Config.prototype.getBoolean =\n  /**\n  * @param {?} key\n  * @param {?=} fallback\n  * @return {?}\n  */\n  function (key, fallback) {\n    /** @type {?} */\n    var c = getConfig();\n    if (c) {\n      return c.getBoolean(key, fallback);\n    }\n    return false;\n  };\n  /**\n   * @param {?} key\n   * @param {?=} fallback\n   * @return {?}\n   */\n  Config.prototype.getNumber =\n  /**\n  * @param {?} key\n  * @param {?=} fallback\n  * @return {?}\n  */\n  function (key, fallback) {\n    /** @type {?} */\n    var c = getConfig();\n    if (c) {\n      return c.getNumber(key, fallback);\n    }\n    return 0;\n  };\n  /**\n   * @param {?} key\n   * @param {?=} value\n   * @return {?}\n   */\n  Config.prototype.set =\n  /**\n  * @param {?} key\n  * @param {?=} value\n  * @return {?}\n  */\n  function (key, value) {\n    console.warn(\"[DEPRECATION][Config]: The Config.set() method is deprecated and will be removed in the next major release.\");\n    /** @type {?} */\n    var c = getConfig();\n    if (c) {\n      c.set(key, value);\n    }\n  };\n  Config.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  Config.ngInjectableDef = defineInjectable({\n    factory: function Config_Factory() {\n      return new Config();\n    },\n    token: Config,\n    providedIn: \"root\"\n  });\n  return Config;\n}();\n/** @type {?} */\nvar ConfigToken = new InjectionToken('USERCONFIG');\n/** @type {?} */\nvar getConfig =\n/**\n* @return {?}\n*/\nfunction () {\n  if (typeof /** @type {?} */window !== 'undefined') {\n    /** @type {?} */\n    var Ionic = /** @type {?} */ /** @type {?} */window.Ionic;\n    if (Ionic && Ionic.config) {\n      return Ionic.config;\n    }\n  }\n  return null;\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * \\@usage\n * ```ts\n * import { NavParams } from '\\@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\nvar\n/**\n* \\@description\n* NavParams are an object that exists on a page and can contain data for that particular view.\n* Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n* option with a simple `get` method.\n*\n* \\@usage\n* ```ts\n* import { NavParams } from '\\@ionic/angular';\n*\n* export class MyClass{\n*\n*  constructor(navParams: NavParams){\n*    // userParams is an object we have in our nav-parameters\n*    navParams.get('userParams');\n*  }\n*\n* }\n* ```\n*/\nNavParams = /** @class */function () {\n  function NavParams(data) {\n    if (data === void 0) {\n      data = {};\n    }\n    this.data = data;\n  }\n  /**\n   * Get the value of a nav-parameter for the current view\n   *\n   * ```ts\n   * import { NavParams } from 'ionic-angular';\n   *\n   * export class MyClass{\n   *  constructor(public navParams: NavParams){\n   *    // userParams is an object we have in our nav-parameters\n   *    this.navParams.get('userParams');\n   *  }\n   * }\n   * ```\n   *\n   * @param param Which param you want to look up\n   */\n  /**\n   * Get the value of a nav-parameter for the current view\n   *\n   * ```ts\n   * import { NavParams } from 'ionic-angular';\n   *\n   * export class MyClass{\n   *  constructor(public navParams: NavParams){\n   *    // userParams is an object we have in our nav-parameters\n   *    this.navParams.get('userParams');\n   *  }\n   * }\n   * ```\n   *\n   * @param {?} param Which param you want to look up\n   * @return {?}\n   */\n  NavParams.prototype.get =\n  /**\n  * Get the value of a nav-parameter for the current view\n  *\n  * ```ts\n  * import { NavParams } from 'ionic-angular';\n  *\n  * export class MyClass{\n  *  constructor(public navParams: NavParams){\n  *    // userParams is an object we have in our nav-parameters\n  *    this.navParams.get('userParams');\n  *  }\n  * }\n  * ```\n  *\n  * @param {?} param Which param you want to look up\n  * @return {?}\n  */\n  function (param) {\n    return this.data[param];\n  };\n  return NavParams;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AngularDelegate = /** @class */function () {\n  function AngularDelegate(zone, appRef) {\n    this.zone = zone;\n    this.appRef = appRef;\n  }\n  /**\n   * @param {?} resolver\n   * @param {?} injector\n   * @param {?=} location\n   * @return {?}\n   */\n  AngularDelegate.prototype.create =\n  /**\n  * @param {?} resolver\n  * @param {?} injector\n  * @param {?=} location\n  * @return {?}\n  */\n  function (resolver, injector, location) {\n    return new AngularFrameworkDelegate(resolver, injector, location, this.appRef, this.zone);\n  };\n  AngularDelegate.decorators = [{\n    type: Injectable\n  }];\n  /** @nocollapse */\n  AngularDelegate.ctorParameters = function () {\n    return [{\n      type: NgZone\n    }, {\n      type: ApplicationRef\n    }];\n  };\n  return AngularDelegate;\n}();\nvar AngularFrameworkDelegate = /** @class */function () {\n  function AngularFrameworkDelegate(resolver, injector, location, appRef, zone) {\n    this.resolver = resolver;\n    this.injector = injector;\n    this.location = location;\n    this.appRef = appRef;\n    this.zone = zone;\n    this.elRefMap = new WeakMap();\n    this.elEventsMap = new WeakMap();\n  }\n  /**\n   * @param {?} container\n   * @param {?} component\n   * @param {?=} params\n   * @param {?=} cssClasses\n   * @return {?}\n   */\n  AngularFrameworkDelegate.prototype.attachViewToDom =\n  /**\n  * @param {?} container\n  * @param {?} component\n  * @param {?=} params\n  * @param {?=} cssClasses\n  * @return {?}\n  */\n  function (container, component, params, cssClasses) {\n    var _this = this;\n    return this.zone.run(\n    /**\n    * @return {?}\n    */\n    function () {\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        /** @type {?} */\n        var el = attachView(_this.zone, _this.resolver, _this.injector, _this.location, _this.appRef, _this.elRefMap, _this.elEventsMap, container, component, params, cssClasses);\n        resolve(el);\n      });\n    });\n  };\n  /**\n   * @param {?} _container\n   * @param {?} component\n   * @return {?}\n   */\n  AngularFrameworkDelegate.prototype.removeViewFromDom =\n  /**\n  * @param {?} _container\n  * @param {?} component\n  * @return {?}\n  */\n  function (_container, component) {\n    var _this = this;\n    return this.zone.run(\n    /**\n    * @return {?}\n    */\n    function () {\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        /** @type {?} */\n        var componentRef = _this.elRefMap.get(component);\n        if (componentRef) {\n          componentRef.destroy();\n          _this.elRefMap.delete(component);\n          /** @type {?} */\n          var unbindEvents = _this.elEventsMap.get(component);\n          if (unbindEvents) {\n            unbindEvents();\n            _this.elEventsMap.delete(component);\n          }\n        }\n        resolve();\n      });\n    });\n  };\n  return AngularFrameworkDelegate;\n}();\n/** @type {?} */\nvar attachView =\n/**\n* @param {?} zone\n* @param {?} resolver\n* @param {?} injector\n* @param {?} location\n* @param {?} appRef\n* @param {?} elRefMap\n* @param {?} elEventsMap\n* @param {?} container\n* @param {?} component\n* @param {?} params\n* @param {?} cssClasses\n* @return {?}\n*/\nfunction (zone, resolver, injector, location, appRef, elRefMap, elEventsMap, container, component, params, cssClasses) {\n  /** @type {?} */\n  var factory = resolver.resolveComponentFactory(component);\n  /** @type {?} */\n  var childInjector = Injector.create({\n    providers: getProviders(params),\n    parent: injector\n  });\n  /** @type {?} */\n  var componentRef = location ? location.createComponent(factory, location.length, childInjector) : factory.create(childInjector);\n  /** @type {?} */\n  var instance = componentRef.instance;\n  /** @type {?} */\n  var hostElement = componentRef.location.nativeElement;\n  if (params) {\n    Object.assign(instance, params);\n  }\n  if (cssClasses) {\n    for (var _i = 0, cssClasses_1 = cssClasses; _i < cssClasses_1.length; _i++) {\n      var clazz = cssClasses_1[_i];\n      hostElement.classList.add(clazz);\n    }\n  }\n  /** @type {?} */\n  var unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n  container.appendChild(hostElement);\n  if (!location) {\n    appRef.attachView(componentRef.hostView);\n  }\n  componentRef.changeDetectorRef.reattach();\n  elRefMap.set(hostElement, componentRef);\n  elEventsMap.set(hostElement, unbindEvents);\n  return hostElement;\n};\n/** @type {?} */\nvar LIFECYCLES = [LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD];\n/** @type {?} */\nvar bindLifecycleEvents =\n/**\n* @param {?} zone\n* @param {?} instance\n* @param {?} element\n* @return {?}\n*/\nfunction (zone, instance, element) {\n  return zone.run(\n  /**\n  * @return {?}\n  */\n  function () {\n    /** @type {?} */\n    var unregisters = LIFECYCLES.filter(\n    /**\n    * @param {?} eventName\n    * @return {?}\n    */\n    function (eventName) {\n      return typeof instance[eventName] === 'function';\n    }).map(\n    /**\n    * @param {?} eventName\n    * @return {?}\n    */\n    function (eventName) {\n      /** @type {?} */\n      var handler =\n      /**\n      * @param {?} ev\n      * @return {?}\n      */\n      function (ev) {\n        return instance[eventName](ev.detail);\n      };\n      element.addEventListener(eventName, handler);\n      return (\n        /**\n        * @return {?}\n        */\n        function () {\n          return element.removeEventListener(eventName, handler);\n        }\n      );\n    });\n    return (\n      /**\n      * @return {?}\n      */\n      function () {\n        return unregisters.forEach(\n        /**\n        * @param {?} fn\n        * @return {?}\n        */\n        function (fn) {\n          return fn();\n        });\n      }\n    );\n  });\n};\n/** @type {?} */\nvar NavParamsToken = new InjectionToken('NavParamsToken');\n/** @type {?} */\nvar getProviders =\n/**\n* @param {?} params\n* @return {?}\n*/\nfunction (params) {\n  return [{\n    provide: NavParamsToken,\n    useValue: params\n  }, {\n    provide: NavParams,\n    useFactory: provideNavParamsInjectable,\n    deps: [NavParamsToken]\n  }];\n};\n/** @type {?} */\nvar provideNavParamsInjectable =\n/**\n* @param {?} params\n* @return {?}\n*/\nfunction (params) {\n  return new NavParams(params);\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar insertView =\n/**\n* @param {?} views\n* @param {?} view\n* @param {?} direction\n* @return {?}\n*/\nfunction (views, view, direction) {\n  if (direction === 'root') {\n    return setRoot(views, view);\n  } else if (direction === 'forward') {\n    return setForward(views, view);\n  } else {\n    return setBack(views, view);\n  }\n};\n/** @type {?} */\nvar setRoot =\n/**\n* @param {?} views\n* @param {?} view\n* @return {?}\n*/\nfunction (views, view) {\n  views = views.filter(\n  /**\n  * @param {?} v\n  * @return {?}\n  */\n  function (v) {\n    return v.stackId !== view.stackId;\n  });\n  views.push(view);\n  return views;\n};\n/** @type {?} */\nvar setForward =\n/**\n* @param {?} views\n* @param {?} view\n* @return {?}\n*/\nfunction (views, view) {\n  /** @type {?} */\n  var index = views.indexOf(view);\n  if (index >= 0) {\n    views = views.filter(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    function (v) {\n      return v.stackId !== view.stackId || v.id <= view.id;\n    });\n  } else {\n    views.push(view);\n  }\n  return views;\n};\n/** @type {?} */\nvar setBack =\n/**\n* @param {?} views\n* @param {?} view\n* @return {?}\n*/\nfunction (views, view) {\n  /** @type {?} */\n  var index = views.indexOf(view);\n  if (index >= 0) {\n    return views.filter(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    function (v) {\n      return v.stackId !== view.stackId || v.id <= view.id;\n    });\n  } else {\n    return setRoot(views, view);\n  }\n};\n/** @type {?} */\nvar getUrl =\n/**\n* @param {?} router\n* @param {?} activatedRoute\n* @return {?}\n*/\nfunction (router, activatedRoute) {\n  /** @type {?} */\n  var urlTree = router.createUrlTree(['.'], {\n    relativeTo: activatedRoute\n  });\n  return router.serializeUrl(urlTree);\n};\n/** @type {?} */\nvar isTabSwitch =\n/**\n* @param {?} enteringView\n* @param {?} leavingView\n* @return {?}\n*/\nfunction (enteringView, leavingView) {\n  if (!leavingView) {\n    return true;\n  }\n  return enteringView.stackId !== leavingView.stackId;\n};\n/** @type {?} */\nvar computeStackId =\n/**\n* @param {?} prefixUrl\n* @param {?} url\n* @return {?}\n*/\nfunction (prefixUrl, url) {\n  if (!prefixUrl) {\n    return undefined;\n  }\n  /** @type {?} */\n  var segments = toSegments(url);\n  for (var i = 0; i < segments.length; i++) {\n    if (i >= prefixUrl.length) {\n      return segments[i];\n    }\n    if (segments[i] !== prefixUrl[i]) {\n      return undefined;\n    }\n  }\n  return undefined;\n};\n/** @type {?} */\nvar toSegments =\n/**\n* @param {?} path\n* @return {?}\n*/\nfunction (path) {\n  return path.split('/').map(\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  function (s) {\n    return s.trim();\n  }).filter(\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  function (s) {\n    return s !== '';\n  });\n};\n/** @type {?} */\nvar destroyView =\n/**\n* @param {?} view\n* @return {?}\n*/\nfunction (view) {\n  if (view) {\n    // TODO lifecycle event\n    view.ref.destroy();\n    view.unlistenEvents();\n  }\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar StackController = /** @class */function () {\n  function StackController(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n    this.containerEl = containerEl;\n    this.router = router;\n    this.navCtrl = navCtrl;\n    this.zone = zone;\n    this.location = location;\n    this.views = [];\n    this.skipTransition = false;\n    this.nextId = 0;\n    this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n  }\n  /**\n   * @param {?} ref\n   * @param {?} activatedRoute\n   * @return {?}\n   */\n  StackController.prototype.createView =\n  /**\n  * @param {?} ref\n  * @param {?} activatedRoute\n  * @return {?}\n  */\n  function (ref, activatedRoute) {\n    /** @type {?} */\n    var url = getUrl(this.router, activatedRoute);\n    /** @type {?} */\n    var element = /** @type {?} */ref && ref.location && ref.location.nativeElement;\n    /** @type {?} */\n    var unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n    return {\n      id: this.nextId++,\n      stackId: computeStackId(this.tabsPrefix, url),\n      unlistenEvents: unlistenEvents,\n      element: element,\n      ref: ref,\n      url: url\n    };\n  };\n  /**\n   * @param {?} activatedRoute\n   * @return {?}\n   */\n  StackController.prototype.getExistingView =\n  /**\n  * @param {?} activatedRoute\n  * @return {?}\n  */\n  function (activatedRoute) {\n    /** @type {?} */\n    var activatedUrlKey = getUrl(this.router, activatedRoute);\n    /** @type {?} */\n    var view = this.views.find(\n    /**\n    * @param {?} vw\n    * @return {?}\n    */\n    function (vw) {\n      return vw.url === activatedUrlKey;\n    });\n    if (view) {\n      view.ref.changeDetectorRef.reattach();\n    }\n    return view;\n  };\n  /**\n   * @param {?} enteringView\n   * @return {?}\n   */\n  StackController.prototype.setActive =\n  /**\n  * @param {?} enteringView\n  * @return {?}\n  */\n  function (enteringView) {\n    var _this = this;\n    var _a = this.navCtrl.consumeTransition(),\n      direction = _a.direction,\n      animation = _a.animation;\n    /** @type {?} */\n    var leavingView = this.activeView;\n    /** @type {?} */\n    var tabSwitch = isTabSwitch(enteringView, leavingView);\n    if (tabSwitch) {\n      direction = 'back';\n      animation = undefined;\n    }\n    /** @type {?} */\n    var viewsSnapshot = this.views.slice();\n    /** @type {?} */\n    var currentNavigation;\n    /** @type {?} */\n    var router = /** @type {?} */this.router;\n    // Angular >= 7.2.0\n    if (router.getCurrentNavigation) {\n      currentNavigation = router.getCurrentNavigation();\n      // Angular < 7.2.0\n    } else if (router.navigations && router.navigations.value) {\n      currentNavigation = router.navigations.value;\n    }\n    /**\n     * If the navigation action\n     * sets `replaceUrl: true`\n     * then we need to make sure\n     * we remove the last item\n     * from our views stack\n     */\n    if (currentNavigation && currentNavigation.extras && currentNavigation.extras.replaceUrl) {\n      if (this.views.length > 0) {\n        this.views.splice(-1, 1);\n      }\n    }\n    /** @type {?} */\n    var reused = this.views.includes(enteringView);\n    /** @type {?} */\n    var views = this.insertView(enteringView, direction);\n    // Trigger change detection before transition starts\n    // This will call ngOnInit() the first time too, just after the view\n    // was attached to the dom, but BEFORE the transition starts\n    if (!reused) {\n      enteringView.ref.changeDetectorRef.detectChanges();\n    }\n    // Wait until previous transitions finish\n    return this.zone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    function () {\n      return _this.wait(\n      /**\n      * @return {?}\n      */\n      function () {\n        // disconnect leaving page from change detection to\n        // reduce jank during the page transition\n        if (leavingView) {\n          leavingView.ref.changeDetectorRef.detach();\n        }\n        // In case the enteringView is the same as the leavingPage we need to reattach()\n        enteringView.ref.changeDetectorRef.reattach();\n        return _this.transition(enteringView, leavingView, animation, _this.canGoBack(1), false).then(\n        /**\n        * @return {?}\n        */\n        function () {\n          return cleanupAsync(enteringView, views, viewsSnapshot, _this.location);\n        }).then(\n        /**\n        * @return {?}\n        */\n        function () {\n          return {\n            enteringView: enteringView,\n            direction: direction,\n            animation: animation,\n            tabSwitch: tabSwitch\n          };\n        });\n      });\n    });\n  };\n  /**\n   * @param {?} deep\n   * @param {?=} stackId\n   * @return {?}\n   */\n  StackController.prototype.canGoBack =\n  /**\n  * @param {?} deep\n  * @param {?=} stackId\n  * @return {?}\n  */\n  function (deep, stackId) {\n    if (stackId === void 0) {\n      stackId = this.getActiveStackId();\n    }\n    return this.getStack(stackId).length > deep;\n  };\n  /**\n   * @param {?} deep\n   * @param {?=} stackId\n   * @return {?}\n   */\n  StackController.prototype.pop =\n  /**\n  * @param {?} deep\n  * @param {?=} stackId\n  * @return {?}\n  */\n  function (deep, stackId) {\n    var _this = this;\n    if (stackId === void 0) {\n      stackId = this.getActiveStackId();\n    }\n    return this.zone.run(\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var views = _this.getStack(stackId);\n      if (views.length <= deep) {\n        return Promise.resolve(false);\n      }\n      /** @type {?} */\n      var view = views[views.length - deep - 1];\n      /** @type {?} */\n      var url = view.url;\n      /** @type {?} */\n      var viewSavedData = view.savedData;\n      if (viewSavedData) {\n        /** @type {?} */\n        var primaryOutlet = viewSavedData.get('primary');\n        if (primaryOutlet && primaryOutlet.route && primaryOutlet.route._routerState && primaryOutlet.route._routerState.snapshot && primaryOutlet.route._routerState.snapshot.url) {\n          url = primaryOutlet.route._routerState.snapshot.url;\n        }\n      }\n      return _this.navCtrl.navigateBack(url, view.savedExtras).then(\n      /**\n      * @return {?}\n      */\n      function () {\n        return true;\n      });\n    });\n  };\n  /**\n   * @return {?}\n   */\n  StackController.prototype.startBackTransition =\n  /**\n  * @return {?}\n  */\n  function () {\n    var _this = this;\n    /** @type {?} */\n    var leavingView = this.activeView;\n    if (leavingView) {\n      /** @type {?} */\n      var views = this.getStack(leavingView.stackId);\n      /** @type {?} */\n      var enteringView_1 = views[views.length - 2];\n      return this.wait(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this.transition(enteringView_1,\n        // entering view\n        leavingView,\n        // leaving view\n        'back', _this.canGoBack(2), true);\n      });\n    }\n    return Promise.resolve();\n  };\n  /**\n   * @param {?} shouldComplete\n   * @return {?}\n   */\n  StackController.prototype.endBackTransition =\n  /**\n  * @param {?} shouldComplete\n  * @return {?}\n  */\n  function (shouldComplete) {\n    if (shouldComplete) {\n      this.skipTransition = true;\n      this.pop(1);\n    } else if (this.activeView) {\n      cleanup(this.activeView, this.views, this.views, this.location);\n    }\n  };\n  /**\n   * @param {?=} stackId\n   * @return {?}\n   */\n  StackController.prototype.getLastUrl =\n  /**\n  * @param {?=} stackId\n  * @return {?}\n  */\n  function (stackId) {\n    /** @type {?} */\n    var views = this.getStack(stackId);\n    return views.length > 0 ? views[views.length - 1] : undefined;\n  };\n  /**\n   * @return {?}\n   */\n  StackController.prototype.getActiveStackId =\n  /**\n  * @return {?}\n  */\n  function () {\n    return this.activeView ? this.activeView.stackId : undefined;\n  };\n  /**\n   * @return {?}\n   */\n  StackController.prototype.destroy =\n  /**\n  * @return {?}\n  */\n  function () {\n    this.containerEl = /** @type {?} */undefined;\n    this.views.forEach(destroyView);\n    this.activeView = undefined;\n    this.views = [];\n  };\n  /**\n   * @private\n   * @param {?} stackId\n   * @return {?}\n   */\n  StackController.prototype.getStack =\n  /**\n  * @private\n  * @param {?} stackId\n  * @return {?}\n  */\n  function (stackId) {\n    return this.views.filter(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    function (v) {\n      return v.stackId === stackId;\n    });\n  };\n  /**\n   * @private\n   * @param {?} enteringView\n   * @param {?} direction\n   * @return {?}\n   */\n  StackController.prototype.insertView =\n  /**\n  * @private\n  * @param {?} enteringView\n  * @param {?} direction\n  * @return {?}\n  */\n  function (enteringView, direction) {\n    this.activeView = enteringView;\n    this.views = insertView(this.views, enteringView, direction);\n    return this.views.slice();\n  };\n  /**\n   * @private\n   * @param {?} enteringView\n   * @param {?} leavingView\n   * @param {?} direction\n   * @param {?} showGoBack\n   * @param {?} progressAnimation\n   * @return {?}\n   */\n  StackController.prototype.transition =\n  /**\n  * @private\n  * @param {?} enteringView\n  * @param {?} leavingView\n  * @param {?} direction\n  * @param {?} showGoBack\n  * @param {?} progressAnimation\n  * @return {?}\n  */\n  function (enteringView, leavingView, direction, showGoBack, progressAnimation) {\n    if (this.skipTransition) {\n      this.skipTransition = false;\n      return Promise.resolve(false);\n    }\n    if (leavingView === enteringView) {\n      return Promise.resolve(false);\n    }\n    /** @type {?} */\n    var enteringEl = enteringView ? enteringView.element : undefined;\n    /** @type {?} */\n    var leavingEl = leavingView ? leavingView.element : undefined;\n    /** @type {?} */\n    var containerEl = this.containerEl;\n    if (enteringEl && enteringEl !== leavingEl) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n      if (enteringEl.parentElement !== containerEl) {\n        containerEl.appendChild(enteringEl);\n      }\n      if ( /** @type {?} */containerEl.commit) {\n        return containerEl.commit(enteringEl, leavingEl, {\n          deepWait: true,\n          duration: direction === undefined ? 0 : undefined,\n          direction: direction,\n          showGoBack: showGoBack,\n          progressAnimation: progressAnimation\n        });\n      }\n    }\n    return Promise.resolve(false);\n  };\n  /**\n   * @private\n   * @template T\n   * @param {?} task\n   * @return {?}\n   */\n  StackController.prototype.wait =\n  /**\n  * @private\n  * @template T\n  * @param {?} task\n  * @return {?}\n  */\n  function (task) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promise;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.runningTask !== undefined)) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.runningTask];\n          case 1:\n            _a.sent();\n            this.runningTask = undefined;\n            _a.label = 2;\n          case 2:\n            promise = this.runningTask = task();\n            return [2 /*return*/, promise];\n        }\n      });\n    });\n  };\n  return StackController;\n}();\n/** @type {?} */\nvar cleanupAsync =\n/**\n* @param {?} activeRoute\n* @param {?} views\n* @param {?} viewsSnapshot\n* @param {?} location\n* @return {?}\n*/\nfunction (activeRoute, views, viewsSnapshot, location) {\n  if (typeof /** @type {?} */requestAnimationFrame === 'function') {\n    return new Promise(\n    /**\n    * @param {?} resolve\n    * @return {?}\n    */\n    function (resolve) {\n      requestAnimationFrame(\n      /**\n      * @return {?}\n      */\n      function () {\n        cleanup(activeRoute, views, viewsSnapshot, location);\n        resolve();\n      });\n    });\n  }\n  return Promise.resolve();\n};\n/** @type {?} */\nvar cleanup =\n/**\n* @param {?} activeRoute\n* @param {?} views\n* @param {?} viewsSnapshot\n* @param {?} location\n* @return {?}\n*/\nfunction (activeRoute, views, viewsSnapshot, location) {\n  viewsSnapshot.filter(\n  /**\n  * @param {?} view\n  * @return {?}\n  */\n  function (view) {\n    return !views.includes(view);\n  }).forEach(destroyView);\n  views.forEach(\n  /**\n  * @param {?} view\n  * @return {?}\n  */\n  function (view) {\n    /**\n     * In the event that a user navigated multiple\n     * times in rapid succession, we want to make sure\n     * we don't pre-emptively detach a view while\n     * it is in mid-transition.\n     *\n     * In this instance we also do not care about query\n     * params or fragments as it will be the same view regardless\n     * @type {?}\n     */\n    var locationWithoutParams = location.path().split('?')[0];\n    /** @type {?} */\n    var locationWithoutFragment = locationWithoutParams.split('#')[0];\n    if (view !== activeRoute && view.url !== locationWithoutFragment) {\n      /** @type {?} */\n      var element = view.element;\n      element.setAttribute('aria-hidden', 'true');\n      element.classList.add('ion-page-hidden');\n      view.ref.changeDetectorRef.detach();\n    }\n  });\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonRouterOutlet = /** @class */function () {\n  function IonRouterOutlet(parentContexts, location, resolver, name, tabs, config, navCtrl, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n    this.parentContexts = parentContexts;\n    this.location = location;\n    this.resolver = resolver;\n    this.config = config;\n    this.navCtrl = navCtrl;\n    this.parentOutlet = parentOutlet;\n    this.activated = null;\n    this.activatedView = null;\n    this._activatedRoute = null;\n    // Maintain map of activated route proxies for each component instance\n    this.proxyMap = new WeakMap();\n    // Keep the latest activated route in a subject for the proxy routes to switch map to\n    this.currentActivatedRoute$ = new BehaviorSubject(null);\n    this.stackEvents = new EventEmitter();\n    this.activateEvents = new EventEmitter();\n    this.deactivateEvents = new EventEmitter();\n    this.nativeEl = elementRef.nativeElement;\n    this.name = name || PRIMARY_OUTLET;\n    this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n    this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, navCtrl, zone, commonLocation);\n    parentContexts.onChildOutletCreated(this.name, /** @type {?} */this);\n  }\n  Object.defineProperty(IonRouterOutlet.prototype, \"animated\", {\n    set:\n    /**\n    * @param {?} animated\n    * @return {?}\n    */\n    function (animated) {\n      this.nativeEl.animated = animated;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IonRouterOutlet.prototype, \"swipeGesture\", {\n    set:\n    /**\n    * @param {?} swipe\n    * @return {?}\n    */\n    function (swipe) {\n      var _this = this;\n      this._swipeGesture = swipe;\n      this.nativeEl.swipeHandler = swipe ? {\n        canStart:\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this.stackCtrl.canGoBack(1);\n        },\n        onStart:\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this.stackCtrl.startBackTransition();\n        },\n        onEnd:\n        /**\n        * @param {?} shouldContinue\n        * @return {?}\n        */\n        function (shouldContinue) {\n          return _this.stackCtrl.endBackTransition(shouldContinue);\n        }\n      } : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.ngOnDestroy =\n  /**\n  * @return {?}\n  */\n  function () {\n    this.stackCtrl.destroy();\n  };\n  /**\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.getContext =\n  /**\n  * @return {?}\n  */\n  function () {\n    return this.parentContexts.getContext(this.name);\n  };\n  /**\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.ngOnInit =\n  /**\n  * @return {?}\n  */\n  function () {\n    var _this = this;\n    if (!this.activated) {\n      // If the outlet was not instantiated at the time the route got activated we need to populate\n      // the outlet when it is initialized (ie inside a NgIf)\n      /** @type {?} */\n      var context = this.getContext();\n      if (context && context.route) {\n        this.activateWith(context.route, context.resolver || null);\n      }\n    }\n    if ( /** @type {?} */this.nativeEl.componentOnReady) {\n      this.nativeEl.componentOnReady().then(\n      /**\n      * @return {?}\n      */\n      function () {\n        if (_this._swipeGesture === undefined) {\n          _this.swipeGesture = _this.config.getBoolean('swipeBackEnabled', /** @type {?} */_this.nativeEl.mode === 'ios');\n        }\n      });\n    }\n  };\n  Object.defineProperty(IonRouterOutlet.prototype, \"isActivated\", {\n    get:\n    /**\n    * @return {?}\n    */\n    function () {\n      return !!this.activated;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IonRouterOutlet.prototype, \"component\", {\n    get:\n    /**\n    * @return {?}\n    */\n    function () {\n      if (!this.activated) {\n        throw new Error('Outlet is not activated');\n      }\n      return this.activated.instance;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IonRouterOutlet.prototype, \"activatedRoute\", {\n    get:\n    /**\n    * @return {?}\n    */\n    function () {\n      if (!this.activated) {\n        throw new Error('Outlet is not activated');\n      }\n      return (/** @type {?} */this._activatedRoute\n      );\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(IonRouterOutlet.prototype, \"activatedRouteData\", {\n    get:\n    /**\n    * @return {?}\n    */\n    function () {\n      if (this._activatedRoute) {\n        return this._activatedRoute.snapshot.data;\n      }\n      return {};\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.detach =\n  /**\n  * Called when the `RouteReuseStrategy` instructs to detach the subtree\n  * @return {?}\n  */\n  function () {\n    throw new Error('incompatible reuse strategy');\n  };\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   * @param {?} _ref\n   * @param {?} _activatedRoute\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.attach =\n  /**\n  * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n  * @param {?} _ref\n  * @param {?} _activatedRoute\n  * @return {?}\n  */\n  function (_ref, _activatedRoute) {\n    throw new Error('incompatible reuse strategy');\n  };\n  /**\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.deactivate =\n  /**\n  * @return {?}\n  */\n  function () {\n    if (this.activated) {\n      if (this.activatedView) {\n        this.activatedView.savedData = new Map( /** @type {?} */this.getContext().children['contexts']);\n        /**\n         * Ensure we are saving the NavigationExtras\n         * data otherwise it will be lost\n         */\n        this.activatedView.savedExtras = {};\n        /** @type {?} */\n        var context = /** @type {?} */this.getContext();\n        if (context.route) {\n          /** @type {?} */\n          var contextSnapshot = context.route.snapshot;\n          this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n          this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n        }\n      }\n      /** @type {?} */\n      var c = this.component;\n      this.activatedView = null;\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  };\n  /**\n   * @param {?} activatedRoute\n   * @param {?} resolver\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.activateWith =\n  /**\n  * @param {?} activatedRoute\n  * @param {?} resolver\n  * @return {?}\n  */\n  function (activatedRoute, resolver) {\n    var _this = this;\n    if (this.isActivated) {\n      throw new Error('Cannot activate an already activated outlet');\n    }\n    this._activatedRoute = activatedRoute;\n    /** @type {?} */\n    var cmpRef;\n    /** @type {?} */\n    var enteringView = this.stackCtrl.getExistingView(activatedRoute);\n    if (enteringView) {\n      cmpRef = this.activated = enteringView.ref;\n      /** @type {?} */\n      var saved = enteringView.savedData;\n      if (saved) {\n        // self-restore\n        /** @type {?} */\n        var context = /** @type {?} */this.getContext();\n        context.children['contexts'] = saved;\n      }\n      // Updated activated route proxy for this component\n      this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n    } else {\n      /** @type {?} */\n      var snapshot = /** @type {?} */activatedRoute._futureSnapshot;\n      /** @type {?} */\n      var component = /** @type {?} */ /** @type {?} */snapshot.routeConfig.component;\n      resolver = resolver || this.resolver;\n      /** @type {?} */\n      var factory = resolver.resolveComponentFactory(component);\n      /** @type {?} */\n      var childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n      // We create an activated route proxy object that will maintain future updates for this component\n      // over its lifecycle in the stack.\n      /** @type {?} */\n      var component$ = new BehaviorSubject(null);\n      /** @type {?} */\n      var activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n      /** @type {?} */\n      var injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\n      cmpRef = this.activated = this.location.createComponent(factory, this.location.length, injector);\n      // Once the component is created we can push it to our local subject supplied to the proxy\n      component$.next(cmpRef.instance);\n      // Calling `markForCheck` to make sure we will run the change detection when the\n      // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n      enteringView = this.stackCtrl.createView(this.activated, activatedRoute);\n      // Store references to the proxy by component\n      this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n      this.currentActivatedRoute$.next({\n        component: cmpRef.instance,\n        activatedRoute: activatedRoute\n      });\n    }\n    this.activatedView = enteringView;\n    this.stackCtrl.setActive(enteringView).then(\n    /**\n    * @param {?} data\n    * @return {?}\n    */\n    function (data) {\n      _this.navCtrl.setTopOutlet(_this);\n      _this.activateEvents.emit(cmpRef.instance);\n      _this.stackEvents.emit(data);\n    });\n  };\n  /**\n   * Returns `true` if there are pages in the stack to go back.\n   */\n  /**\n   * Returns `true` if there are pages in the stack to go back.\n   * @param {?=} deep\n   * @param {?=} stackId\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.canGoBack =\n  /**\n  * Returns `true` if there are pages in the stack to go back.\n  * @param {?=} deep\n  * @param {?=} stackId\n  * @return {?}\n  */\n  function (deep, stackId) {\n    if (deep === void 0) {\n      deep = 1;\n    }\n    return this.stackCtrl.canGoBack(deep, stackId);\n  };\n  /**\n   * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n   */\n  /**\n   * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n   * @param {?=} deep\n   * @param {?=} stackId\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.pop =\n  /**\n  * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n  * @param {?=} deep\n  * @param {?=} stackId\n  * @return {?}\n  */\n  function (deep, stackId) {\n    if (deep === void 0) {\n      deep = 1;\n    }\n    return this.stackCtrl.pop(deep, stackId);\n  };\n  /**\n   * Returns the URL of the active page of each stack.\n   */\n  /**\n   * Returns the URL of the active page of each stack.\n   * @param {?=} stackId\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.getLastUrl =\n  /**\n  * Returns the URL of the active page of each stack.\n  * @param {?=} stackId\n  * @return {?}\n  */\n  function (stackId) {\n    /** @type {?} */\n    var active = this.stackCtrl.getLastUrl(stackId);\n    return active ? active.url : undefined;\n  };\n  /**\n   * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n   */\n  /**\n   * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.getActiveStackId =\n  /**\n  * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n  * @return {?}\n  */\n  function () {\n    return this.stackCtrl.getActiveStackId();\n  };\n  /**\n   * Since the activated route can change over the life time of a component in an ion router outlet, we create\n   * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n   */\n  /**\n   * Since the activated route can change over the life time of a component in an ion router outlet, we create\n   * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n   * @private\n   * @param {?} component$\n   * @param {?} activatedRoute\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.createActivatedRouteProxy =\n  /**\n  * Since the activated route can change over the life time of a component in an ion router outlet, we create\n  * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n  * @private\n  * @param {?} component$\n  * @param {?} activatedRoute\n  * @return {?}\n  */\n  function (component$, activatedRoute) {\n    /** @type {?} */\n    var proxy = new ActivatedRoute();\n    proxy._futureSnapshot = /** @type {?} */activatedRoute._futureSnapshot;\n    proxy._routerState = /** @type {?} */activatedRoute._routerState;\n    proxy.snapshot = activatedRoute.snapshot;\n    proxy.outlet = activatedRoute.outlet;\n    proxy.component = activatedRoute.component;\n    // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n    /** @type {?} */proxy._paramMap = this.proxyObservable(component$, 'paramMap');\n    /** @type {?} */proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n    proxy.url = this.proxyObservable(component$, 'url');\n    proxy.params = this.proxyObservable(component$, 'params');\n    proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n    proxy.fragment = this.proxyObservable(component$, 'fragment');\n    proxy.data = this.proxyObservable(component$, 'data');\n    return (/** @type {?} */proxy\n    );\n  };\n  /**\n   * Create a wrapped observable that will switch to the latest activated route matched by the given component\n   */\n  /**\n   * Create a wrapped observable that will switch to the latest activated route matched by the given component\n   * @private\n   * @param {?} component$\n   * @param {?} path\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.proxyObservable =\n  /**\n  * Create a wrapped observable that will switch to the latest activated route matched by the given component\n  * @private\n  * @param {?} component$\n  * @param {?} path\n  * @return {?}\n  */\n  function (component$, path) {\n    var _this = this;\n    return component$.pipe(\n    // First wait until the component instance is pushed\n    filter(\n    /**\n    * @param {?} component\n    * @return {?}\n    */\n    function (component) {\n      return !!component;\n    }), switchMap(\n    /**\n    * @param {?} component\n    * @return {?}\n    */\n    function (component) {\n      return _this.currentActivatedRoute$.pipe(filter(\n      /**\n      * @param {?} current\n      * @return {?}\n      */\n      function (current) {\n        return current !== null && current.component === component;\n      }), switchMap(\n      /**\n      * @param {?} current\n      * @return {?}\n      */\n      function (current) {\n        return current && /** @type {?} */current.activatedRoute[path];\n      }), distinctUntilChanged());\n    }));\n  };\n  /**\n   * Updates the activated route proxy for the given component to the new incoming router state\n   */\n  /**\n   * Updates the activated route proxy for the given component to the new incoming router state\n   * @private\n   * @param {?} component\n   * @param {?} activatedRoute\n   * @return {?}\n   */\n  IonRouterOutlet.prototype.updateActivatedRouteProxy =\n  /**\n  * Updates the activated route proxy for the given component to the new incoming router state\n  * @private\n  * @param {?} component\n  * @param {?} activatedRoute\n  * @return {?}\n  */\n  function (component, activatedRoute) {\n    /** @type {?} */\n    var proxy = this.proxyMap.get(component);\n    if (!proxy) {\n      throw new Error(\"Could not find activated route proxy for view\");\n    }\n    /** @type {?} */proxy._futureSnapshot = /** @type {?} */activatedRoute._futureSnapshot;\n    /** @type {?} */proxy._routerState = /** @type {?} */activatedRoute._routerState;\n    proxy.snapshot = activatedRoute.snapshot;\n    proxy.outlet = activatedRoute.outlet;\n    proxy.component = activatedRoute.component;\n    this.currentActivatedRoute$.next({\n      component: component,\n      activatedRoute: activatedRoute\n    });\n  };\n  IonRouterOutlet.decorators = [{\n    type: Directive,\n    args: [{\n      selector: 'ion-router-outlet',\n      exportAs: 'outlet',\n      inputs: ['animated', 'swipeGesture']\n    }]\n  }];\n  /** @nocollapse */\n  IonRouterOutlet.ctorParameters = function () {\n    return [{\n      type: ChildrenOutletContexts\n    }, {\n      type: ViewContainerRef\n    }, {\n      type: ComponentFactoryResolver\n    }, {\n      type: String,\n      decorators: [{\n        type: Attribute,\n        args: ['name']\n      }]\n    }, {\n      type: String,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Attribute,\n        args: ['tabs']\n      }]\n    }, {\n      type: Config\n    }, {\n      type: NavController\n    }, {\n      type: Location\n    }, {\n      type: ElementRef\n    }, {\n      type: Router\n    }, {\n      type: NgZone\n    }, {\n      type: ActivatedRoute\n    }, {\n      type: IonRouterOutlet,\n      decorators: [{\n        type: SkipSelf\n      }, {\n        type: Optional\n      }]\n    }];\n  };\n  IonRouterOutlet.propDecorators = {\n    stackEvents: [{\n      type: Output\n    }],\n    activateEvents: [{\n      type: Output,\n      args: ['activate']\n    }],\n    deactivateEvents: [{\n      type: Output,\n      args: ['deactivate']\n    }]\n  };\n  return IonRouterOutlet;\n}();\nvar OutletInjector = /** @class */function () {\n  function OutletInjector(route, childContexts, parent) {\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n  /**\n   * @param {?} token\n   * @param {?=} notFoundValue\n   * @return {?}\n   */\n  OutletInjector.prototype.get =\n  /**\n  * @param {?} token\n  * @param {?=} notFoundValue\n  * @return {?}\n  */\n  function (token, notFoundValue) {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n    // tslint:disable-next-line\n    return this.parent.get(token, notFoundValue);\n  };\n  return OutletInjector;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonTabs = /** @class */function () {\n  function IonTabs(navCtrl) {\n    this.navCtrl = navCtrl;\n    this.ionTabsWillChange = new EventEmitter();\n    this.ionTabsDidChange = new EventEmitter();\n  }\n  /**\n   * @internal\n   */\n  /**\n   * \\@internal\n   * @param {?} detail\n   * @return {?}\n   */\n  IonTabs.prototype.onPageSelected =\n  /**\n  * \\@internal\n  * @param {?} detail\n  * @return {?}\n  */\n  function (detail) {\n    /** @type {?} */\n    var stackId = detail.enteringView.stackId;\n    if (detail.tabSwitch && stackId !== undefined) {\n      if (this.tabBar) {\n        this.tabBar.selectedTab = stackId;\n      }\n      this.ionTabsWillChange.emit({\n        tab: stackId\n      });\n      this.ionTabsDidChange.emit({\n        tab: stackId\n      });\n    }\n  };\n  /**\n   * @param {?} tab\n   * @return {?}\n   */\n  IonTabs.prototype.select =\n  /**\n  * @param {?} tab\n  * @return {?}\n  */\n  function (tab) {\n    /** @type {?} */\n    var alreadySelected = this.outlet.getActiveStackId() === tab;\n    /** @type {?} */\n    var href = this.outlet.tabsPrefix + \"/\" + tab;\n    /** @type {?} */\n    var url = alreadySelected ? href : this.outlet.getLastUrl(tab) || href;\n    return this.navCtrl.navigateRoot(url, {\n      animated: true,\n      animationDirection: 'back'\n    });\n  };\n  /**\n   * @return {?}\n   */\n  IonTabs.prototype.getSelected =\n  /**\n  * @return {?}\n  */\n  function () {\n    return this.outlet.getActiveStackId();\n  };\n  IonTabs.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-tabs',\n      template: \"\\n    <ng-content select=\\\"[slot=top]\\\"></ng-content>\\n    <div class=\\\"tabs-inner\\\">\\n      <ion-router-outlet #outlet tabs=\\\"true\\\" (stackEvents)=\\\"onPageSelected($event)\\\"></ion-router-outlet>\\n    </div>\\n    <ng-content></ng-content>\",\n      styles: [\"\\n    :host {\\n      display: flex;\\n      position: absolute;\\n      top: 0;\\n      left: 0;\\n      right: 0;\\n      bottom: 0;\\n\\n      flex-direction: column;\\n\\n      width: 100%;\\n      height: 100%;\\n\\n      contain: layout size style;\\n      z-index: $z-index-page-container;\\n    }\\n    .tabs-inner {\\n      position: relative;\\n\\n      flex: 1;\\n\\n      contain: layout size style;\\n    }\"]\n    }]\n  }];\n  /** @nocollapse */\n  IonTabs.ctorParameters = function () {\n    return [{\n      type: NavController\n    }];\n  };\n  IonTabs.propDecorators = {\n    outlet: [{\n      type: ViewChild,\n      args: ['outlet', {\n        read: IonRouterOutlet\n      }]\n    }],\n    tabBar: [{\n      type: ContentChild,\n      args: [IonTabBar]\n    }],\n    ionTabsWillChange: [{\n      type: Output\n    }],\n    ionTabsDidChange: [{\n      type: Output\n    }],\n    select: [{\n      type: HostListener,\n      args: ['ionTabButtonClick', ['$event.detail.tab']]\n    }]\n  };\n  return IonTabs;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonBackButtonDelegate = /** @class */function () {\n  function IonBackButtonDelegate(routerOutlet, navCtrl) {\n    this.routerOutlet = routerOutlet;\n    this.navCtrl = navCtrl;\n  }\n  /**\n   * @internal\n   */\n  /**\n   * \\@internal\n   * @param {?} ev\n   * @return {?}\n   */\n  IonBackButtonDelegate.prototype.onClick =\n  /**\n  * \\@internal\n  * @param {?} ev\n  * @return {?}\n  */\n  function (ev) {\n    if (this.routerOutlet && this.routerOutlet.canGoBack()) {\n      this.routerOutlet.pop();\n      ev.preventDefault();\n    } else if (this.defaultHref != null) {\n      this.navCtrl.navigateBack(this.defaultHref);\n      ev.preventDefault();\n    }\n  };\n  IonBackButtonDelegate.decorators = [{\n    type: Directive,\n    args: [{\n      selector: 'ion-back-button',\n      inputs: ['defaultHref']\n    }]\n  }];\n  /** @nocollapse */\n  IonBackButtonDelegate.ctorParameters = function () {\n    return [{\n      type: IonRouterOutlet,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: NavController\n    }];\n  };\n  IonBackButtonDelegate.propDecorators = {\n    onClick: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }]\n  };\n  return IonBackButtonDelegate;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NavDelegate = /** @class */function () {\n  function NavDelegate(ref, resolver, injector, angularDelegate, location) {\n    ref.nativeElement.delegate = angularDelegate.create(resolver, injector, location);\n  }\n  NavDelegate.decorators = [{\n    type: Directive,\n    args: [{\n      selector: 'ion-nav'\n    }]\n  }];\n  /** @nocollapse */\n  NavDelegate.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: ComponentFactoryResolver\n    }, {\n      type: Injector\n    }, {\n      type: AngularDelegate\n    }, {\n      type: ViewContainerRef\n    }];\n  };\n  return NavDelegate;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar RouterLinkDelegate = /** @class */function () {\n  function RouterLinkDelegate(locationStrategy, navCtrl, elementRef, router, routerLink) {\n    this.locationStrategy = locationStrategy;\n    this.navCtrl = navCtrl;\n    this.elementRef = elementRef;\n    this.router = router;\n    this.routerLink = routerLink;\n    this.routerDirection = 'forward';\n  }\n  /**\n   * @return {?}\n   */\n  RouterLinkDelegate.prototype.ngOnInit =\n  /**\n  * @return {?}\n  */\n  function () {\n    this.updateTargetUrlAndHref();\n  };\n  /**\n   * @return {?}\n   */\n  RouterLinkDelegate.prototype.ngOnChanges =\n  /**\n  * @return {?}\n  */\n  function () {\n    this.updateTargetUrlAndHref();\n  };\n  /**\n   * @return {?}\n   */\n  RouterLinkDelegate.prototype.ngOnDestroy =\n  /**\n  * @return {?}\n  */\n  function () {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  };\n  /**\n   * @private\n   * @return {?}\n   */\n  RouterLinkDelegate.prototype.updateTargetUrlAndHref =\n  /**\n  * @private\n  * @return {?}\n  */\n  function () {\n    if (this.routerLink) {\n      /** @type {?} */\n      var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n      this.elementRef.nativeElement.href = href;\n    }\n  };\n  /**\n   * @internal\n   */\n  /**\n   * \\@internal\n   * @param {?} ev\n   * @return {?}\n   */\n  RouterLinkDelegate.prototype.onClick =\n  /**\n  * \\@internal\n  * @param {?} ev\n  * @return {?}\n  */\n  function (ev) {\n    this.navCtrl.setDirection(this.routerDirection);\n    ev.preventDefault();\n  };\n  RouterLinkDelegate.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[routerLink]',\n      inputs: ['routerDirection']\n    }]\n  }];\n  /** @nocollapse */\n  RouterLinkDelegate.ctorParameters = function () {\n    return [{\n      type: LocationStrategy\n    }, {\n      type: NavController\n    }, {\n      type: ElementRef\n    }, {\n      type: Router\n    }, {\n      type: RouterLink,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  };\n  RouterLinkDelegate.propDecorators = {\n    onClick: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }]\n  };\n  return RouterLinkDelegate;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @hidden\n */\nvar VirtualFooter = /** @class */function () {\n  function VirtualFooter(templateRef) {\n    this.templateRef = templateRef;\n  }\n  VirtualFooter.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[virtualFooter]'\n    }]\n  }];\n  /** @nocollapse */\n  VirtualFooter.ctorParameters = function () {\n    return [{\n      type: TemplateRef\n    }];\n  };\n  return VirtualFooter;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @hidden\n */\nvar VirtualHeader = /** @class */function () {\n  function VirtualHeader(templateRef) {\n    this.templateRef = templateRef;\n  }\n  VirtualHeader.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[virtualHeader]'\n    }]\n  }];\n  /** @nocollapse */\n  VirtualHeader.ctorParameters = function () {\n    return [{\n      type: TemplateRef\n    }];\n  };\n  return VirtualHeader;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @hidden\n */\nvar VirtualItem = /** @class */function () {\n  function VirtualItem(templateRef, viewContainer) {\n    this.templateRef = templateRef;\n    this.viewContainer = viewContainer;\n  }\n  VirtualItem.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[virtualItem]'\n    }]\n  }];\n  /** @nocollapse */\n  VirtualItem.ctorParameters = function () {\n    return [{\n      type: TemplateRef\n    }, {\n      type: ViewContainerRef\n    }];\n  };\n  return VirtualItem;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonVirtualScroll = /** @class */function () {\n  function IonVirtualScroll(z, iterableDiffers, elementRef) {\n    this.z = z;\n    this.iterableDiffers = iterableDiffers;\n    this.refMap = new WeakMap();\n    this.el = /** @type {?} */elementRef.nativeElement;\n    this.el.nodeRender = this.nodeRender.bind(this);\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n  IonVirtualScroll.prototype.ngOnChanges =\n  /**\n  * @param {?} changes\n  * @return {?}\n  */\n  function (changes) {\n    if (this.trackBy && 'items' in changes) {\n      // React on virtualScroll changes only once all inputs have been initialized\n      /** @type {?} */\n      var value = changes['items'].currentValue;\n      if (this.differ === undefined && value != null) {\n        try {\n          this.differ = this.iterableDiffers.find(value).create(this.trackBy);\n        } catch (e) {\n          throw new Error(\"Cannot find a differ supporting object '\" + value + \"'. VirtualScroll only supports binding to Iterables such as Arrays.\");\n        }\n      }\n    }\n  };\n  /**\n   * @return {?}\n   */\n  IonVirtualScroll.prototype.ngDoCheck =\n  /**\n  * @return {?}\n  */\n  function () {\n    // and if there actually are changes\n    /** @type {?} */\n    var changes = this.differ !== undefined && this.items ? this.differ.diff(this.items) : null;\n    if (changes === null) {\n      return;\n    }\n    // TODO: optimize\n    this.checkRange(0);\n  };\n  /**\n   * @private\n   * @param {?} el\n   * @param {?} cell\n   * @param {?} index\n   * @return {?}\n   */\n  IonVirtualScroll.prototype.nodeRender =\n  /**\n  * @private\n  * @param {?} el\n  * @param {?} cell\n  * @param {?} index\n  * @return {?}\n  */\n  function (el, cell, index) {\n    var _this = this;\n    return this.z.run(\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var node;\n      if (!el) {\n        node = _this.itmTmp.viewContainer.createEmbeddedView(_this.getComponent(cell.type), {\n          $implicit: cell.value,\n          index: index\n        }, index);\n        el = getElement(node);\n        _this.refMap.set(el, node);\n      } else {\n        node = /** @type {?} */_this.refMap.get(el);\n        /** @type {?} */\n        var ctx = node.context;\n        ctx.$implicit = cell.value;\n        ctx.index = cell.index;\n      }\n      // run sync change detections\n      node.detectChanges();\n      return el;\n    });\n  };\n  /**\n   * @private\n   * @param {?} type\n   * @return {?}\n   */\n  IonVirtualScroll.prototype.getComponent =\n  /**\n  * @private\n  * @param {?} type\n  * @return {?}\n  */\n  function (type) {\n    switch (type) {\n      case 'item':\n        return this.itmTmp.templateRef;\n      case 'header':\n        return this.hdrTmp.templateRef;\n      case 'footer':\n        return this.ftrTmp.templateRef;\n    }\n    throw new Error('template for virtual item was not provided');\n  };\n  IonVirtualScroll.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ion-virtual-scroll',\n      template: '<ng-content></ng-content>',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      inputs: ['approxItemHeight', 'approxHeaderHeight', 'approxFooterHeight', 'headerFn', 'footerFn', 'items', 'itemHeight', 'headerHeight', 'footerHeight', 'trackBy']\n    }]\n  }];\n  /** @nocollapse */\n  IonVirtualScroll.ctorParameters = function () {\n    return [{\n      type: NgZone\n    }, {\n      type: IterableDiffers\n    }, {\n      type: ElementRef\n    }];\n  };\n  IonVirtualScroll.propDecorators = {\n    itmTmp: [{\n      type: ContentChild,\n      args: [VirtualItem]\n    }],\n    hdrTmp: [{\n      type: ContentChild,\n      args: [VirtualHeader]\n    }],\n    ftrTmp: [{\n      type: ContentChild,\n      args: [VirtualFooter]\n    }]\n  };\n  return IonVirtualScroll;\n}();\n/** @type {?} */\nvar getElement =\n/**\n* @param {?} view\n* @return {?}\n*/\nfunction (view) {\n  /** @type {?} */\n  var rootNodes = view.rootNodes;\n  for (var i = 0; i < rootNodes.length; i++) {\n    if (rootNodes[i].nodeType === 1) {\n      return rootNodes[i];\n    }\n  }\n  throw new Error('virtual element was not created');\n};\nproxyInputs(IonVirtualScroll, ['approxItemHeight', 'approxHeaderHeight', 'approxFooterHeight', 'headerFn', 'footerFn', 'items', 'itemHeight', 'headerHeight', 'footerHeight']);\nproxyMethods(IonVirtualScroll, ['checkEnd', 'checkRange', 'positionForItem']);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CssUtilsDeprecations = /** @class */function () {\n  function CssUtilsDeprecations(ref) {\n    /** @type {?} */\n    var el = /** @type {?} */ref.nativeElement;\n    /** @type {?} */\n    var attributes = Array.from(el.attributes).map(\n    /**\n    * @param {?} a\n    * @return {?}\n    */\n    function (a) {\n      return a.name;\n    }).filter(\n    /**\n    * @param {?} n\n    * @return {?}\n    */\n    function (n) {\n      return DEPRECATED_ATTRIBUTES.includes(n);\n    });\n    if (attributes.length > 0) {\n      console.warn(\"[DEPRECATED][CSS] Ionic CSS attributes are deprecated.\\nReplace:\\n'<\" + el.tagName.toLowerCase() + \" \" + attributes.map(\n      /**\n      * @param {?} n\n      * @return {?}\n      */\n      function (n) {\n        return \"\" + n;\n      }).join(' ') + \">'\\n\\nWith:\\n'<\" + el.tagName.toLowerCase() + \" class=\\\"\" + attributes.map(\n      /**\n      * @param {?} n\n      * @return {?}\n      */\n      function (n) {\n        return \"ion-\" + n;\n      }).join(' ') + \"\\\">'\\n      \");\n    }\n  }\n  CssUtilsDeprecations.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[align-self-start], [align-self-end], [align-self-center], [align-self-stretch], [align-self-baseline], [align-self-auto], [wrap-reverse], [justify-content-start], [justify-content-center], [justify-content-end], [justify-content-around], [justify-content-between], [justify-content-evenly], [align-items-start], [align-items-center], [align-items-end], [align-items-stretch], [align-items-baseline], [float-left], [float-right], [float-start], [float-end], [float-sm-left], [float-sm-right], [float-sm-start], [float-sm-end], [float-md-left], [float-md-right], [float-md-start], [float-md-end], [float-lg-left], [float-lg-right], [float-lg-start], [float-lg-end], [float-xl-left], [float-xl-right], [float-xl-start], [float-xl-end], [text-center], [text-justify], [text-start], [text-end], [text-left], [text-right], [text-nowrap], [text-wrap], [text-sm-center], [text-sm-justify], [text-sm-start], [text-sm-end], [text-sm-left], [text-sm-right], [text-sm-nowrap], [text-sm-wrap], [text-md-center], [text-md-justify], [text-md-start], [text-md-end], [text-md-left], [text-md-right], [text-md-nowrap], [text-md-wrap], [text-lg-center], [text-lg-justify], [text-lg-start], [text-lg-end], [text-lg-left], [text-lg-right], [text-lg-nowrap], [text-lg-wrap], [text-xl-center], [text-xl-justify], [text-xl-start], [text-xl-end], [text-xl-left], [text-xl-right], [text-xl-nowrap], [text-xl-wrap], [text-uppercase], [text-lowercase], [text-capitalize], [text-sm-uppercase], [text-sm-lowercase], [text-sm-capitalize], [text-md-uppercase], [text-md-lowercase], [text-md-capitalize], [text-lg-uppercase], [text-lg-lowercase], [text-lg-capitalize], [text-xl-uppercase], [text-xl-lowercase], [text-xl-capitalize], [no-padding], [padding], [padding-top], [padding-bottom], [padding-start], [padding-end], [padding-vertical], [padding-horizontal], [no-margin], [margin], [margin-top], [margin-bottom], [margin-start], [margin-end], [margin-vertical], [margin-horizontal]'\n    }]\n  }];\n  /** @nocollapse */\n  CssUtilsDeprecations.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }];\n  };\n  return CssUtilsDeprecations;\n}();\n/** @type {?} */\nvar DEPRECATED_ATTRIBUTES = ['align-self-start', 'align-self-end', 'align-self-center', 'align-self-stretch', 'align-self-baseline', 'align-self-auto', 'wrap-reverse', 'justify-content-start', 'justify-content-center', 'justify-content-end', 'justify-content-around', 'justify-content-between', 'justify-content-evenly', 'align-items-start', 'align-items-center', 'align-items-end', 'align-items-stretch', 'align-items-baseline', 'float-left', 'float-right', 'float-start', 'float-end', 'float-sm-left', 'float-sm-right', 'float-sm-start', 'float-sm-end', 'float-md-left', 'float-md-right', 'float-md-start', 'float-md-end', 'float-lg-left', 'float-lg-right', 'float-lg-start', 'float-lg-end', 'float-xl-left', 'float-xl-right', 'float-xl-start', 'float-xl-end', 'text-center', 'text-justify', 'text-start', 'text-end', 'text-left', 'text-right', 'text-nowrap', 'text-wrap', 'text-sm-center', 'text-sm-justify', 'text-sm-start', 'text-sm-end', 'text-sm-left', 'text-sm-right', 'text-sm-nowrap', 'text-sm-wrap', 'text-md-center', 'text-md-justify', 'text-md-start', 'text-md-end', 'text-md-left', 'text-md-right', 'text-md-nowrap', 'text-md-wrap', 'text-lg-center', 'text-lg-justify', 'text-lg-start', 'text-lg-end', 'text-lg-left', 'text-lg-right', 'text-lg-nowrap', 'text-lg-wrap', 'text-xl-center', 'text-xl-justify', 'text-xl-start', 'text-xl-end', 'text-xl-left', 'text-xl-right', 'text-xl-nowrap', 'text-xl-wrap', 'text-uppercase', 'text-lowercase', 'text-capitalize', 'text-sm-uppercase', 'text-sm-lowercase', 'text-sm-capitalize', 'text-md-uppercase', 'text-md-lowercase', 'text-md-capitalize', 'text-lg-uppercase', 'text-lg-lowercase', 'text-lg-capitalize', 'text-xl-uppercase', 'text-xl-lowercase', 'text-xl-capitalize', 'no-padding', 'padding', 'padding-top', 'padding-bottom', 'padding-start', 'padding-end', 'padding-vertical', 'padding-horizontal', 'no-margin', 'margin', 'margin-top', 'margin-bottom', 'margin-start', 'margin-end', 'margin-vertical', 'margin-horizontal'];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template Opts, Overlay\n */\nvar\n/**\n* @template Opts, Overlay\n*/\nOverlayBaseController = /** @class */function () {\n  function OverlayBaseController(ctrl) {\n    this.ctrl = ctrl;\n  }\n  /**\n   * Creates a new overlay\n   */\n  /**\n   * Creates a new overlay\n   * @param {?=} opts\n   * @return {?}\n   */\n  OverlayBaseController.prototype.create =\n  /**\n  * Creates a new overlay\n  * @param {?=} opts\n  * @return {?}\n  */\n  function (opts) {\n    // TODO: next major release opts is not optional\n    return this.ctrl.create( /** @type {?} */opts || {});\n  };\n  /**\n   * When `id` is not provided, it dismisses the top overlay.\n   */\n  /**\n   * When `id` is not provided, it dismisses the top overlay.\n   * @param {?=} data\n   * @param {?=} role\n   * @param {?=} id\n   * @return {?}\n   */\n  OverlayBaseController.prototype.dismiss =\n  /**\n  * When `id` is not provided, it dismisses the top overlay.\n  * @param {?=} data\n  * @param {?=} role\n  * @param {?=} id\n  * @return {?}\n  */\n  function (data, role, id) {\n    return this.ctrl.dismiss(data, role, id);\n  };\n  /**\n   * Returns the top overlay.\n   */\n  /**\n   * Returns the top overlay.\n   * @return {?}\n   */\n  OverlayBaseController.prototype.getTop =\n  /**\n  * Returns the top overlay.\n  * @return {?}\n  */\n  function () {\n    return this.ctrl.getTop();\n  };\n  return OverlayBaseController;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ActionSheetController = /** @class */function (_super) {\n  __extends(ActionSheetController, _super);\n  function ActionSheetController() {\n    return _super.call(this, actionSheetController) || this;\n  }\n  ActionSheetController.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  ActionSheetController.ctorParameters = function () {\n    return [];\n  };\n  /** @nocollapse */\n  ActionSheetController.ngInjectableDef = defineInjectable({\n    factory: function ActionSheetController_Factory() {\n      return new ActionSheetController();\n    },\n    token: ActionSheetController,\n    providedIn: \"root\"\n  });\n  return ActionSheetController;\n}(OverlayBaseController);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar AlertController = /** @class */function (_super) {\n  __extends(AlertController, _super);\n  function AlertController() {\n    return _super.call(this, alertController) || this;\n  }\n  AlertController.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  AlertController.ctorParameters = function () {\n    return [];\n  };\n  /** @nocollapse */\n  AlertController.ngInjectableDef = defineInjectable({\n    factory: function AlertController_Factory() {\n      return new AlertController();\n    },\n    token: AlertController,\n    providedIn: \"root\"\n  });\n  return AlertController;\n}(OverlayBaseController);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar Events = /** @class */function () {\n  function Events() {\n    this.c = new Map();\n    console.warn(\"[DEPRECATION][Events]: The Events provider is deprecated and it will be removed in the next major release.\\n  - Use \\\"Observables\\\" for a similar pub/sub architecture: https://angular.io/guide/observables\\n  - Use \\\"Redux\\\" for advanced state management: https://ngrx.io\");\n  }\n  /**\n   * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.\n   *\n   * @param topic the topic to subscribe to\n   * @param handler the event handler\n   */\n  /**\n   * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.\n   *\n   * @param {?} topic the topic to subscribe to\n   * @param {...?} handlers\n   * @return {?}\n   */\n  Events.prototype.subscribe =\n  /**\n  * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.\n  *\n  * @param {?} topic the topic to subscribe to\n  * @param {...?} handlers\n  * @return {?}\n  */\n  function (topic) {\n    var handlers = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      handlers[_i - 1] = arguments[_i];\n    }\n    /** @type {?} */\n    var topics = this.c.get(topic);\n    if (!topics) {\n      this.c.set(topic, topics = []);\n    }\n    topics.push.apply(topics, handlers);\n  };\n  /**\n   * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.\n   *\n   * @param topic the topic to unsubscribe from\n   * @param handler the event handler\n   *\n   * @return true if a handler was removed\n   */\n  /**\n   * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.\n   *\n   * @param {?} topic the topic to unsubscribe from\n   * @param {?=} handler the event handler\n   *\n   * @return {?} true if a handler was removed\n   */\n  Events.prototype.unsubscribe =\n  /**\n  * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.\n  *\n  * @param {?} topic the topic to unsubscribe from\n  * @param {?=} handler the event handler\n  *\n  * @return {?} true if a handler was removed\n  */\n  function (topic, handler) {\n    if (!handler) {\n      return this.c.delete(topic);\n    }\n    /** @type {?} */\n    var topics = this.c.get(topic);\n    if (!topics) {\n      return false;\n    }\n    // We need to find and remove a specific handler\n    /** @type {?} */\n    var index = topics.indexOf(handler);\n    if (index < 0) {\n      // Wasn't found, wasn't removed\n      return false;\n    }\n    topics.splice(index, 1);\n    if (topics.length === 0) {\n      this.c.delete(topic);\n    }\n    return true;\n  };\n  /**\n   * Publish an event to the given topic.\n   *\n   * @param topic the topic to publish to\n   * @param eventData the data to send as the event\n   */\n  /**\n   * Publish an event to the given topic.\n   *\n   * @param {?} topic the topic to publish to\n   * @param {...?} args\n   * @return {?}\n   */\n  Events.prototype.publish =\n  /**\n  * Publish an event to the given topic.\n  *\n  * @param {?} topic the topic to publish to\n  * @param {...?} args\n  * @return {?}\n  */\n  function (topic) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    /** @type {?} */\n    var topics = this.c.get(topic);\n    if (!topics) {\n      return null;\n    }\n    return topics.map(\n    /**\n    * @param {?} handler\n    * @return {?}\n    */\n    function (handler) {\n      try {\n        return handler.apply(void 0, args);\n      } catch (e) {\n        console.error(e);\n        return null;\n      }\n    });\n  };\n  Events.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  Events.ctorParameters = function () {\n    return [];\n  };\n  /** @nocollapse */\n  Events.ngInjectableDef = defineInjectable({\n    factory: function Events_Factory() {\n      return new Events();\n    },\n    token: Events,\n    providedIn: \"root\"\n  });\n  return Events;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar LoadingController = /** @class */function (_super) {\n  __extends(LoadingController, _super);\n  function LoadingController() {\n    return _super.call(this, loadingController) || this;\n  }\n  LoadingController.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  LoadingController.ctorParameters = function () {\n    return [];\n  };\n  /** @nocollapse */\n  LoadingController.ngInjectableDef = defineInjectable({\n    factory: function LoadingController_Factory() {\n      return new LoadingController();\n    },\n    token: LoadingController,\n    providedIn: \"root\"\n  });\n  return LoadingController;\n}(OverlayBaseController);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MenuController = /** @class */function () {\n  function MenuController() {}\n  /**\n   * Programmatically open the Menu.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu is fully opened\n   */\n  /**\n   * Programmatically open the Menu.\n   * @param {?=} menuId\n   * @return {?} returns a promise when the menu is fully opened\n   */\n  MenuController.prototype.open =\n  /**\n  * Programmatically open the Menu.\n  * @param {?=} menuId\n  * @return {?} returns a promise when the menu is fully opened\n  */\n  function (menuId) {\n    return menuController.open(menuId);\n  };\n  /**\n   * Programmatically close the Menu. If no `menuId` is given as the first\n   * argument then it'll close any menu which is open. If a `menuId`\n   * is given then it'll close that exact menu.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu is fully closed\n   */\n  /**\n   * Programmatically close the Menu. If no `menuId` is given as the first\n   * argument then it'll close any menu which is open. If a `menuId`\n   * is given then it'll close that exact menu.\n   * @param {?=} menuId\n   * @return {?} returns a promise when the menu is fully closed\n   */\n  MenuController.prototype.close =\n  /**\n  * Programmatically close the Menu. If no `menuId` is given as the first\n  * argument then it'll close any menu which is open. If a `menuId`\n  * is given then it'll close that exact menu.\n  * @param {?=} menuId\n  * @return {?} returns a promise when the menu is fully closed\n  */\n  function (menuId) {\n    return menuController.close(menuId);\n  };\n  /**\n   * Toggle the menu. If it's closed, it will open, and if opened, it\n   * will close.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu has been toggled\n   */\n  /**\n   * Toggle the menu. If it's closed, it will open, and if opened, it\n   * will close.\n   * @param {?=} menuId\n   * @return {?} returns a promise when the menu has been toggled\n   */\n  MenuController.prototype.toggle =\n  /**\n  * Toggle the menu. If it's closed, it will open, and if opened, it\n  * will close.\n  * @param {?=} menuId\n  * @return {?} returns a promise when the menu has been toggled\n  */\n  function (menuId) {\n    return menuController.toggle(menuId);\n  };\n  /**\n   * Used to enable or disable a menu. For example, there could be multiple\n   * left menus, but only one of them should be able to be opened at the same\n   * time. If there are multiple menus on the same side, then enabling one menu\n   * will also automatically disable all the others that are on the same side.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu, which is useful for chaining.\n   */\n  /**\n   * Used to enable or disable a menu. For example, there could be multiple\n   * left menus, but only one of them should be able to be opened at the same\n   * time. If there are multiple menus on the same side, then enabling one menu\n   * will also automatically disable all the others that are on the same side.\n   * @param {?} shouldEnable\n   * @param {?=} menuId\n   * @return {?} Returns the instance of the menu, which is useful for chaining.\n   */\n  MenuController.prototype.enable =\n  /**\n  * Used to enable or disable a menu. For example, there could be multiple\n  * left menus, but only one of them should be able to be opened at the same\n  * time. If there are multiple menus on the same side, then enabling one menu\n  * will also automatically disable all the others that are on the same side.\n  * @param {?} shouldEnable\n  * @param {?=} menuId\n  * @return {?} Returns the instance of the menu, which is useful for chaining.\n  */\n  function (shouldEnable, menuId) {\n    return menuController.enable(shouldEnable, menuId);\n  };\n  /**\n   * Used to enable or disable the ability to swipe open the menu.\n   * @param shouldEnable  True if it should be swipe-able, false if not.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu, which is useful for chaining.\n   * @deprecated Use swipeGesture() instead.\n   */\n  /**\n   * Used to enable or disable the ability to swipe open the menu.\n   * @deprecated Use swipeGesture() instead.\n   * @param {?} shouldEnable  True if it should be swipe-able, false if not.\n   * @param {?=} menuId\n   * @return {?} Returns the instance of the menu, which is useful for chaining.\n   */\n  MenuController.prototype.swipeEnable =\n  /**\n  * Used to enable or disable the ability to swipe open the menu.\n  * @deprecated Use swipeGesture() instead.\n  * @param {?} shouldEnable  True if it should be swipe-able, false if not.\n  * @param {?=} menuId\n  * @return {?} Returns the instance of the menu, which is useful for chaining.\n  */\n  function (shouldEnable, menuId) {\n    console.warn('[DEPRECATED][ion-menu-controller] swipeEnable() is deprecated. Use MenuController.swipeGesture() instead');\n    return this.swipeGesture(shouldEnable, menuId);\n  };\n  /**\n   * Used to enable or disable the ability to swipe open the menu.\n   * @param shouldEnable  True if it should be swipe-able, false if not.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu, which is useful for chaining.\n   */\n  /**\n   * Used to enable or disable the ability to swipe open the menu.\n   * @param {?} shouldEnable  True if it should be swipe-able, false if not.\n   * @param {?=} menuId\n   * @return {?} Returns the instance of the menu, which is useful for chaining.\n   */\n  MenuController.prototype.swipeGesture =\n  /**\n  * Used to enable or disable the ability to swipe open the menu.\n  * @param {?} shouldEnable  True if it should be swipe-able, false if not.\n  * @param {?=} menuId\n  * @return {?} Returns the instance of the menu, which is useful for chaining.\n  */\n  function (shouldEnable, menuId) {\n    return menuController.swipeGesture(shouldEnable, menuId);\n  };\n  /**\n   * @param [menuId] Optionally get the menu by its id, or side.\n   * @return Returns true if the specified menu is currently open, otherwise false.\n   * If the menuId is not specified, it returns true if ANY menu is currenly open.\n   */\n  /**\n   * @param {?=} menuId\n   * @return {?} Returns true if the specified menu is currently open, otherwise false.\n   * If the menuId is not specified, it returns true if ANY menu is currenly open.\n   */\n  MenuController.prototype.isOpen =\n  /**\n  * @param {?=} menuId\n  * @return {?} Returns true if the specified menu is currently open, otherwise false.\n  * If the menuId is not specified, it returns true if ANY menu is currenly open.\n  */\n  function (menuId) {\n    return menuController.isOpen(menuId);\n  };\n  /**\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns true if the menu is currently enabled, otherwise false.\n   */\n  /**\n   * @param {?=} menuId\n   * @return {?} Returns true if the menu is currently enabled, otherwise false.\n   */\n  MenuController.prototype.isEnabled =\n  /**\n  * @param {?=} menuId\n  * @return {?} Returns true if the menu is currently enabled, otherwise false.\n  */\n  function (menuId) {\n    return menuController.isEnabled(menuId);\n  };\n  /**\n   * Used to get a menu instance. If a `menuId` is not provided then it'll\n   * return the first menu found. If a `menuId` is `left` or `right`, then\n   * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n   * provided, then it'll try to find the menu using the menu's `id`\n   * property. If a menu is not found then it'll return `null`.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu if found, otherwise `null`.\n   */\n  /**\n   * Used to get a menu instance. If a `menuId` is not provided then it'll\n   * return the first menu found. If a `menuId` is `left` or `right`, then\n   * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n   * provided, then it'll try to find the menu using the menu's `id`\n   * property. If a menu is not found then it'll return `null`.\n   * @param {?=} menuId\n   * @return {?} Returns the instance of the menu if found, otherwise `null`.\n   */\n  MenuController.prototype.get =\n  /**\n  * Used to get a menu instance. If a `menuId` is not provided then it'll\n  * return the first menu found. If a `menuId` is `left` or `right`, then\n  * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n  * provided, then it'll try to find the menu using the menu's `id`\n  * property. If a menu is not found then it'll return `null`.\n  * @param {?=} menuId\n  * @return {?} Returns the instance of the menu if found, otherwise `null`.\n  */\n  function (menuId) {\n    return menuController.get(menuId);\n  };\n  /**\n   * @return Returns the instance of the menu already opened, otherwise `null`.\n   */\n  /**\n   * @return {?} Returns the instance of the menu already opened, otherwise `null`.\n   */\n  MenuController.prototype.getOpen =\n  /**\n  * @return {?} Returns the instance of the menu already opened, otherwise `null`.\n  */\n  function () {\n    return menuController.getOpen();\n  };\n  /**\n   * @return Returns an array of all menu instances.\n   */\n  /**\n   * @return {?} Returns an array of all menu instances.\n   */\n  MenuController.prototype.getMenus =\n  /**\n  * @return {?} Returns an array of all menu instances.\n  */\n  function () {\n    return menuController.getMenus();\n  };\n  MenuController.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  MenuController.ngInjectableDef = defineInjectable({\n    factory: function MenuController_Factory() {\n      return new MenuController();\n    },\n    token: MenuController,\n    providedIn: \"root\"\n  });\n  return MenuController;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar PickerController = /** @class */function (_super) {\n  __extends(PickerController, _super);\n  function PickerController() {\n    return _super.call(this, pickerController) || this;\n  }\n  PickerController.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  PickerController.ctorParameters = function () {\n    return [];\n  };\n  /** @nocollapse */\n  PickerController.ngInjectableDef = defineInjectable({\n    factory: function PickerController_Factory() {\n      return new PickerController();\n    },\n    token: PickerController,\n    providedIn: \"root\"\n  });\n  return PickerController;\n}(OverlayBaseController);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ModalController = /** @class */function (_super) {\n  __extends(ModalController, _super);\n  function ModalController(angularDelegate, resolver, injector) {\n    var _this = _super.call(this, modalController) || this;\n    _this.angularDelegate = angularDelegate;\n    _this.resolver = resolver;\n    _this.injector = injector;\n    return _this;\n  }\n  /**\n   * @param {?} opts\n   * @return {?}\n   */\n  ModalController.prototype.create =\n  /**\n  * @param {?} opts\n  * @return {?}\n  */\n  function (opts) {\n    return _super.prototype.create.call(this, __assign({}, opts, {\n      delegate: this.angularDelegate.create(this.resolver, this.injector)\n    }));\n  };\n  ModalController.decorators = [{\n    type: Injectable\n  }];\n  /** @nocollapse */\n  ModalController.ctorParameters = function () {\n    return [{\n      type: AngularDelegate\n    }, {\n      type: ComponentFactoryResolver\n    }, {\n      type: Injector\n    }];\n  };\n  return ModalController;\n}(OverlayBaseController);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar PopoverController = /** @class */function (_super) {\n  __extends(PopoverController, _super);\n  function PopoverController(angularDelegate, resolver, injector) {\n    var _this = _super.call(this, popoverController) || this;\n    _this.angularDelegate = angularDelegate;\n    _this.resolver = resolver;\n    _this.injector = injector;\n    return _this;\n  }\n  /**\n   * @param {?} opts\n   * @return {?}\n   */\n  PopoverController.prototype.create =\n  /**\n  * @param {?} opts\n  * @return {?}\n  */\n  function (opts) {\n    return _super.prototype.create.call(this, __assign({}, opts, {\n      delegate: this.angularDelegate.create(this.resolver, this.injector)\n    }));\n  };\n  PopoverController.decorators = [{\n    type: Injectable\n  }];\n  /** @nocollapse */\n  PopoverController.ctorParameters = function () {\n    return [{\n      type: AngularDelegate\n    }, {\n      type: ComponentFactoryResolver\n    }, {\n      type: Injector\n    }];\n  };\n  return PopoverController;\n}(OverlayBaseController);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ToastController = /** @class */function (_super) {\n  __extends(ToastController, _super);\n  function ToastController() {\n    return _super.call(this, toastController) || this;\n  }\n  ToastController.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  ToastController.ctorParameters = function () {\n    return [];\n  };\n  /** @nocollapse */\n  ToastController.ngInjectableDef = defineInjectable({\n    factory: function ToastController_Factory() {\n      return new ToastController();\n    },\n    token: ToastController,\n    providedIn: \"root\"\n  });\n  return ToastController;\n}(OverlayBaseController);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar DomController = /** @class */function () {\n  function DomController() {}\n  /**\n   * Schedules a task to run during the READ phase of the next frame.\n   * This task should only read the DOM, but never modify it.\n   */\n  /**\n   * Schedules a task to run during the READ phase of the next frame.\n   * This task should only read the DOM, but never modify it.\n   * @param {?} cb\n   * @return {?}\n   */\n  DomController.prototype.read =\n  /**\n  * Schedules a task to run during the READ phase of the next frame.\n  * This task should only read the DOM, but never modify it.\n  * @param {?} cb\n  * @return {?}\n  */\n  function (cb) {\n    getQueue().read(cb);\n  };\n  /**\n   * Schedules a task to run during the WRITE phase of the next frame.\n   * This task should write the DOM, but never READ it.\n   */\n  /**\n   * Schedules a task to run during the WRITE phase of the next frame.\n   * This task should write the DOM, but never READ it.\n   * @param {?} cb\n   * @return {?}\n   */\n  DomController.prototype.write =\n  /**\n  * Schedules a task to run during the WRITE phase of the next frame.\n  * This task should write the DOM, but never READ it.\n  * @param {?} cb\n  * @return {?}\n  */\n  function (cb) {\n    getQueue().write(cb);\n  };\n  DomController.decorators = [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }];\n  /** @nocollapse */\n  DomController.ngInjectableDef = defineInjectable({\n    factory: function DomController_Factory() {\n      return new DomController();\n    },\n    token: DomController,\n    providedIn: \"root\"\n  });\n  return DomController;\n}();\n/** @type {?} */\nvar getQueue =\n/**\n* @return {?}\n*/\nfunction () {\n  /** @type {?} */\n  var win = typeof /** @type {?} */window !== 'undefined' ? window : /** @type {?} */null;\n  if (win != null) {\n    /** @type {?} */\n    var Ionic = win.Ionic;\n    if (Ionic && Ionic.queue) {\n      return Ionic.queue;\n    }\n    return {\n      read:\n      /**\n      * @param {?} cb\n      * @return {?}\n      */\n      function (cb) {\n        return win.requestAnimationFrame(cb);\n      },\n      write:\n      /**\n      * @param {?} cb\n      * @return {?}\n      */\n      function (cb) {\n        return win.requestAnimationFrame(cb);\n      }\n    };\n  }\n  return {\n    read:\n    /**\n    * @param {?} cb\n    * @return {?}\n    */\n    function (cb) {\n      return cb();\n    },\n    write:\n    /**\n    * @param {?} cb\n    * @return {?}\n    */\n    function (cb) {\n      return cb();\n    }\n  };\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar IonicRouteStrategy = /** @class */function () {\n  function IonicRouteStrategy() {}\n  /**\n   * @param {?} _route\n   * @return {?}\n   */\n  IonicRouteStrategy.prototype.shouldDetach =\n  /**\n  * @param {?} _route\n  * @return {?}\n  */\n  function (_route) {\n    return false;\n  };\n  /**\n   * @param {?} _route\n   * @return {?}\n   */\n  IonicRouteStrategy.prototype.shouldAttach =\n  /**\n  * @param {?} _route\n  * @return {?}\n  */\n  function (_route) {\n    return false;\n  };\n  /**\n   * @param {?} _route\n   * @param {?} _detachedTree\n   * @return {?}\n   */\n  IonicRouteStrategy.prototype.store =\n  /**\n  * @param {?} _route\n  * @param {?} _detachedTree\n  * @return {?}\n  */\n  function (_route, _detachedTree) {\n    return;\n  };\n  /**\n   * @param {?} _route\n   * @return {?}\n   */\n  IonicRouteStrategy.prototype.retrieve =\n  /**\n  * @param {?} _route\n  * @return {?}\n  */\n  function (_route) {\n    return null;\n  };\n  /**\n   * @param {?} future\n   * @param {?} curr\n   * @return {?}\n   */\n  IonicRouteStrategy.prototype.shouldReuseRoute =\n  /**\n  * @param {?} future\n  * @param {?} curr\n  * @return {?}\n  */\n  function (future, curr) {\n    if (future.routeConfig !== curr.routeConfig) {\n      return false;\n    }\n    // checking router params\n    /** @type {?} */\n    var futureParams = future.params;\n    /** @type {?} */\n    var currentParams = curr.params;\n    /** @type {?} */\n    var keysA = Object.keys(futureParams);\n    /** @type {?} */\n    var keysB = Object.keys(currentParams);\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n    // Test for A's keys different from B.\n    for (var _i = 0, keysA_1 = keysA; _i < keysA_1.length; _i++) {\n      var key = keysA_1[_i];\n      if (currentParams[key] !== futureParams[key]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  return IonicRouteStrategy;\n}();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar didInitialize = false;\n/** @type {?} */\nvar appInitialize =\n/**\n* @param {?} config\n* @param {?} doc\n* @param {?} zone\n* @return {?}\n*/\nfunction (config, doc, zone) {\n  return (\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var win = /** @type {?} */doc.defaultView;\n      if (win) {\n        if (didInitialize) {\n          console.warn('Ionic Angular was already initialized. Make sure IonicModule.forRoot() is just called once.');\n        }\n        didInitialize = true;\n        /** @type {?} */\n        var Ionic = win.Ionic = win.Ionic || {};\n        Ionic.config = __assign({}, config, {\n          _zoneGate:\n          /**\n          * @param {?} h\n          * @return {?}\n          */\n          function (h) {\n            return zone.run(h);\n          }\n        });\n        /** @type {?} */\n        var aelFn_1 = '__zone_symbol__addEventListener' in /** @type {?} */doc.body ? '__zone_symbol__addEventListener' : 'addEventListener';\n        return applyPolyfills().then(\n        /**\n        * @return {?}\n        */\n        function () {\n          return defineCustomElements(win, {\n            exclude: ['ion-tabs', 'ion-tab'],\n            syncQueue: true,\n            raf: raf,\n            jmp:\n            /**\n            * @param {?} h\n            * @return {?}\n            */\n            function (h) {\n              return zone.runOutsideAngular(h);\n            },\n            ael:\n            /**\n            * @param {?} elm\n            * @param {?} eventName\n            * @param {?} cb\n            * @param {?} opts\n            * @return {?}\n            */\n            function (elm, eventName, cb, opts) {\n              /** @type {?} */elm[aelFn_1](eventName, cb, opts);\n            },\n            rel:\n            /**\n            * @param {?} elm\n            * @param {?} eventName\n            * @param {?} cb\n            * @param {?} opts\n            * @return {?}\n            */\n            function (elm, eventName, cb, opts) {\n              elm.removeEventListener(eventName, cb, opts);\n            }\n          });\n        });\n      }\n    }\n  );\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar DECLARATIONS = [\n// proxies\nIonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNavPop, IonNavPush, IonNavSetRoot, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonText, IonTextarea, IonThumbnail, IonToggle, IonToolbar, IonTitle, IonTabs,\n// ngModel accessors\nBooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor,\n// navigation\nIonRouterOutlet, IonBackButtonDelegate, NavDelegate, RouterLinkDelegate,\n// virtual scroll\nVirtualFooter, VirtualHeader, VirtualItem, IonVirtualScroll,\n// Deprecations\nCssUtilsDeprecations];\nvar IonicModule = /** @class */function () {\n  function IonicModule() {}\n  /**\n   * @param {?=} config\n   * @return {?}\n   */\n  IonicModule.forRoot =\n  /**\n  * @param {?=} config\n  * @return {?}\n  */\n  function (config) {\n    return {\n      ngModule: IonicModule,\n      providers: [{\n        provide: ConfigToken,\n        useValue: config\n      }, {\n        provide: APP_INITIALIZER,\n        useFactory: appInitialize,\n        multi: true,\n        deps: [ConfigToken, DOCUMENT, NgZone]\n      }]\n    };\n  };\n  IonicModule.decorators = [{\n    type: NgModule,\n    args: [{\n      declarations: DECLARATIONS,\n      exports: DECLARATIONS,\n      providers: [AngularDelegate, ModalController, PopoverController],\n      imports: [CommonModule]\n    }]\n  }];\n  return IonicModule;\n}();\nexport { ActionSheetController, AlertController, AngularDelegate, BooleanValueAccessor, Config, CssUtilsDeprecations, DomController, Events, IonApp, IonAvatar, IonBackButton, IonBackButtonDelegate, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNavPop, IonNavPush, IonNavSetRoot, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToggle, IonToolbar, IonVirtualScroll, IonicModule, IonicRouteStrategy, LoadingController, MenuController, ModalController, NavController, NavDelegate, NavParams, NumericValueAccessor, PickerController, Platform, PopoverController, RadioValueAccessor, RouterLinkDelegate, SelectValueAccessor, TextValueAccessor, ToastController, VirtualFooter, VirtualHeader, VirtualItem, ConfigToken as a, ValueAccessor as b, OverlayBaseController as d, appInitialize as e };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}